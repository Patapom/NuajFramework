using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using SharpDX;
using SharpDX.Direct3D;
using SharpDX.Direct3D10;
using Nuaj;

namespace Nuaj.Cirrus
{
	/// <summary>
	/// This is the render technique that is able to render voxel-clouds
	/// </example>
	public class RenderTechniqueVoxelClouds : RenderTechnique
	{
		#region CONSTANTS

		protected const float	VOXEL_BLOCK_SIZE = 4.0f;			// The size of a block of voxels in WORLD units

		protected const int		MAX_VOXELS_PER_FRAME = 8;			// Amount of voxel to compute per frame

		// These determine the size of the volume texture to compute
		protected const int		DENSITY_VOXEL_CELLS_COUNT = 16;
		protected const int		DENSITY_VOXEL_CORNERS_COUNT = DENSITY_VOXEL_CELLS_COUNT+1;
		protected const int		DENSITY_VOXEL_TEXTURE_SIZE = 1+DENSITY_VOXEL_CORNERS_COUNT+1;	// The "+1" guards are margins. We need this additional margin to compute the normal for border vertices

		// These determine the resolution of the voxels within each block
		// It's better to use smaller blocks with the same resolution than go above a resolution of 64

		// High-LOD (USE AT YOUR OWN RISKS ! I HAD TO REBOOT THE PC 3 TIMES ALREADY ! ^___^ )
//		protected const int		VOXEL_CELLS_COUNT = 64;
//		protected const int		MAX_TRIANGLES_COUNT_PER_VOXEL = 3*32*32*32;	// The maximum amount of triangles to emit per voxel
		// Low-LOD
		protected const int		VOXEL_CELLS_COUNT = 16;
		protected const int		MAX_TRIANGLES_COUNT_PER_VOXEL = 3*12*12*12;	// The maximum amount of triangles to emit per voxel
		protected const int		VOXEL_CORNERS_COUNT = VOXEL_CELLS_COUNT+1;


		// Depth maps
		protected const int		DEPTH_MAP_SIZE = 1024;

		// Scattering table
		public const int		SH_ORDER = 3;
		public const int		SH_SQORDER = SH_ORDER*SH_ORDER;
		public const int		SLAB_TEXTURE_SIZE = 128;		// Thickness and height will be encoded in a 128x128 texture for each length step
		public const int		SLAB_TEXTURE_DEPTH = 32;		// Length will be encoded in 32 slices of the 128x128 textures
		public const int		PHASE_TEXTURE_LENGTH = 1024;	// Length of the Mie phase texture

		#endregion

		#region NESTED TYPES

		/// <summary>
		/// This class hosts a volume element geometry
		/// </summary>
		public class	Voxel
		{
			#region FIELDS

			protected RenderTechniqueVoxelClouds	m_Owner = null;

			// Linked list
			protected Voxel		m_Previous = null;
			protected Voxel		m_Next = null;

			// Amount of cells in the voxel
			protected int		m_CellsCount = 0;

			// Size of a block in World space
			protected float		m_WorldBlockSize = 1.0f;

			// Voxel position as integer block indices
			protected int[]		m_PositionInt = new int[3];

			// The voxel position
			protected Vector3	m_Position = Vector3.Zero;

			// The geometry buffer that was generated by a stream output from the density volume
			protected StreamOutputBuffer<VS_P3N3>	m_Geometry = null;

			protected int		m_ID = 0;
			protected static int	ms_UniqueID = 0;

			#endregion

			#region PROPERTIES

			public Voxel	Previous		{ get { return m_Previous; } set { m_Previous = value; } }
			public Voxel	Next			{ get { return m_Next; } set { m_Next = value; } }

			public int		BlockPositionX	{ get { return m_PositionInt[0]; } set { m_PositionInt[0] = value; UpdatePosition(); } }
			public int		BlockPositionY	{ get { return m_PositionInt[1]; } set { m_PositionInt[1] = value; UpdatePosition(); } }
			public int		BlockPositionZ	{ get { return m_PositionInt[2]; } set { m_PositionInt[2] = value; UpdatePosition(); } }

			public float	BlockSize		{ get { return m_WorldBlockSize; } }
			public Vector3	Position		{ get { return m_Position; } }

			public StreamOutputBuffer<VS_P3N3>	Geometry		{ get { return m_Geometry; } }

			#endregion

			#region METHODS

			public Voxel( RenderTechniqueVoxelClouds _Owner, int _CellsCount, float _WorldBlockSize )
			{
				m_Owner = _Owner;
				m_CellsCount = _CellsCount;
				m_WorldBlockSize = _WorldBlockSize;

				// Create the vertex buffer that will be filled by the stream output
				// It will contain the faces that need to be displayed to render the density volume
				int	MaxVertices = 3 * MAX_TRIANGLES_COUNT_PER_VOXEL;
				m_Geometry = m_Owner.ToDispose( new StreamOutputBuffer<VS_P3N3>( m_Owner.Device, "Geometry", MaxVertices ) );
			
				m_ID = ms_UniqueID++;
			}

			public override string ToString()
			{
				return "[" + m_ID + "] (" + m_PositionInt[0] + ", " + m_PositionInt[1] + ", " + m_PositionInt[2] + ")";
			}

			protected void	UpdatePosition()
			{
				m_Position.X = m_PositionInt[0] * m_WorldBlockSize;
				m_Position.Y = m_PositionInt[1] * m_WorldBlockSize;
				m_Position.Z = m_PositionInt[2] * m_WorldBlockSize;
			}

			#endregion
		}

		[System.Runtime.InteropServices.StructLayout( System.Runtime.InteropServices.LayoutKind.Sequential )]
		protected struct VS_UIntX_UIntY
		{
			[Semantic( "POSITION_X" )]
			public UInt32	PositionX;
			[Semantic( "POSITION_Y" )]
			public UInt32	PositionY;
		}

		public class SHVector
		{
			public double[]	V = new double[SH_SQORDER];

			public void	Read( System.IO.BinaryReader _Reader )
			{
				for ( int SHCoeffIndex=0; SHCoeffIndex < SH_SQORDER; SHCoeffIndex++ )
					V[SHCoeffIndex] = _Reader.ReadDouble();
			}
			public void	Write( System.IO.BinaryWriter _Writer )
			{
				for ( int SHCoeffIndex=0; SHCoeffIndex < SH_SQORDER; SHCoeffIndex++ )
					_Writer.Write( V[SHCoeffIndex] );
			}
		}

		#endregion

		#region FIELDS

		// The compulsory camera & light for rendering
		protected Camera					m_Camera = null;
		protected DirectionalLight			m_Light = null;
		protected bool						m_bLightDirty = false;

		//////////////////////////////////////////////////////////////////////////
		// Density + geometry building
		protected Material<VS_P3T2>			m_MaterialBuildDensity = null;
		protected Material<VS_UIntX_UIntY>	m_MaterialBuildGeometry = null;
		protected Material<VS_P3N3>			m_MaterialBuildDepthMaps = null;
		protected Material<VS_P3N3>			m_MaterialDisplayVoxel = null;

		// The quad VB used to render densities into the 3D texture
		protected VertexBuffer<VS_P3T2>		m_DensityQuadVB = null;

		// The slice of NxN voxel position elements used to generate the geometry
		protected VertexBuffer<VS_UIntX_UIntY>	m_VoxelSliceVB = null;

		// The list of computed voxels
		protected Voxel						m_ComputedVoxelsRoot = null;

		// The list of voxels yet to compute
		protected Voxel						m_NotComputedVoxelsRoot = null;

		// The list of available voxels
		protected Voxel						m_AvailableVoxelsRoot = null;

		// The list of volume textures that can be filled per frame
		protected RenderTarget3D<PF_R16F>[]	m_DensityTextures = new RenderTarget3D<PF_R16F>[MAX_VOXELS_PER_FRAME];

		// The depth maps
		protected DepthStencil<PF_D32>		m_DepthMapDepthStencil = null;
		protected RenderTarget<PF_R16F>		m_DepthMapLight = null;
		protected RenderTarget<PF_R16F>		m_DepthMapCamera = null;
		protected RenderTarget<PF_RGBA16F>	m_EnterMapLight = null;
		protected RenderTarget<PF_RGBA16F>	m_EnterMapCamera = null;
		protected RenderTarget<PF_RGBA16F>	m_ExitMapLight = null;
		protected RenderTarget<PF_RGBA16F>	m_ExitMapCamera = null;

		// The scattering table as 3x3D tables
		protected Texture3D<PF_RGBA16F>		m_ScatteringTable0 = null;
		protected Texture3D<PF_RGBA16F>		m_ScatteringTable1 = null;
		protected Texture3D<PF_R16F>		m_ScatteringTable2 = null;
		protected Texture2D<PF_R16F>		m_PhaseTable = null;

		// 8 Random rotation matrices
		protected Matrix[]					m_RandomRotation = new Matrix[8];


		protected float	m_PlaneDistance = 0.0f;
		public float	PlaneDistance
		{
			get { return m_PlaneDistance; }
			set { m_PlaneDistance = value; ClearVoxelGeometries(); }
		}

		#endregion

		#region PROPERTIES

		/// <summary>
		/// Gets or sets the camera that will be used to receive shadows
		/// </summary>
		public Camera						Camera	{ get { return m_Camera; } set { m_Camera = value; } }

		/// <summary>
		/// Gets or sets the light that will be used to cast shadows
		/// </summary>
		public DirectionalLight				Light	{ get { return m_Light; } set { m_Light = value; UpdateLight(); } }

		#endregion

		#region METHODS

		public	RenderTechniqueVoxelClouds( Device _Device, string _Name ) : base( _Device, _Name )
		{
			// Create our main materials
			m_MaterialBuildDensity = ToDispose( new Material<VS_P3T2>( m_Device, "Build Density Material", ShaderModel.SM4_0, new System.IO.FileInfo( "FX/Clouds/BuildDensityVolume.fx" ) ) );
			m_MaterialBuildGeometry = ToDispose( new Material<VS_UIntX_UIntY>( m_Device, "Build Geometry Material", ShaderModel.SM4_0, new System.IO.FileInfo( "FX/Clouds/BuildGeometry.fx" ) ) );
			m_MaterialBuildDepthMaps = ToDispose( new Material<VS_P3N3>( m_Device, "Build Depth Maps Material", ShaderModel.SM4_0, new System.IO.FileInfo( "FX/Clouds/ComputeDepthMap.fx" ) ) );
			m_MaterialDisplayVoxel = ToDispose( new Material<VS_P3N3>( m_Device, "Display Voxel", ShaderModel.SM4_0, new System.IO.FileInfo( "FX/Clouds/DisplayVoxel.fx" ) ) );


			//////////////////////////////////////////////////////////////////////////
			// Create the fixed number of density targets to compute the density for candidate voxels (i.e. voxels yet needing computation)
			for ( int DensityTextureIndex=0; DensityTextureIndex < MAX_VOXELS_PER_FRAME; DensityTextureIndex++ )
				m_DensityTextures[DensityTextureIndex] = ToDispose( new RenderTarget3D<PF_R16F>( Device, "Density Texture #" + DensityTextureIndex, DENSITY_VOXEL_TEXTURE_SIZE, DENSITY_VOXEL_TEXTURE_SIZE, DENSITY_VOXEL_TEXTURE_SIZE, 1 ) );


			//////////////////////////////////////////////////////////////////////////
			// Create the geometries

			// Create the quad VB used to render the densities
			VS_P3T2[]	Vertices = new VS_P3T2[]
			{	//  vertices are organized for a triangle strip with 2 triangles
				new VS_P3T2() { Position=new Vector3( -1.0f, +1.0f, 0.0f ), UV=new Vector2( 0.0f, 0.0f ) },
				new VS_P3T2() { Position=new Vector3( -1.0f, -1.0f, 0.0f ), UV=new Vector2( 0.0f, 1.0f ) },
				new VS_P3T2() { Position=new Vector3( +1.0f, +1.0f, 0.0f ), UV=new Vector2( 1.0f, 0.0f ) },
				new VS_P3T2() { Position=new Vector3( +1.0f, -1.0f, 0.0f ), UV=new Vector2( 1.0f, 1.0f ) },
			};

			m_DensityQuadVB = ToDispose( new VertexBuffer<VS_P3T2>( m_Device, "DensityQuadVB", Vertices ) );

			// Create the voxel slice made of points, one for each cell in a single depth slice of a voxel
			VS_UIntX_UIntY[]	Vertices2 = new VS_UIntX_UIntY[VOXEL_CELLS_COUNT*VOXEL_CELLS_COUNT];
			for ( int Y=0; Y < VOXEL_CELLS_COUNT; Y++ )
				for ( int X=0; X < VOXEL_CELLS_COUNT; X++ )
				{
					Vertices2[VOXEL_CELLS_COUNT*Y+X].PositionX = (uint) X;
					Vertices2[VOXEL_CELLS_COUNT*Y+X].PositionY = (uint) Y;
				}
			m_VoxelSliceVB = ToDispose( new VertexBuffer<VS_UIntX_UIntY>( m_Device, "VoxelSliceVB", Vertices2 ) );

			//////////////////////////////////////////////////////////////////////////
			// Build 8 random rotation matrices
			Random	RNG = new Random( 1 );
			for ( int i=0; i < 8; i++ )
				m_RandomRotation[i] = Matrix.RotationYawPitchRoll( (float) RNG.NextDouble(), (float) RNG.NextDouble(), (float) RNG.NextDouble() );

			//////////////////////////////////////////////////////////////////////////
			// Create the scattering & phase texture tables
			LoadScatteringTable();
			BuildPhaseFunction();

			//////////////////////////////////////////////////////////////////////////
			// Create depth maps
			m_DepthMapDepthStencil = ToDispose( new DepthStencil<PF_D32>( m_Device, "DepthMap DepthStencil", DEPTH_MAP_SIZE, DEPTH_MAP_SIZE, false ) );
			m_DepthMapLight = ToDispose( new RenderTarget<PF_R16F>( m_Device, "DepthMap Light", DEPTH_MAP_SIZE, DEPTH_MAP_SIZE, 1 ) );
			m_DepthMapCamera = ToDispose( new RenderTarget<PF_R16F>( m_Device, "DepthMap Camera", DEPTH_MAP_SIZE, DEPTH_MAP_SIZE, 1 ) );
			m_EnterMapLight = ToDispose( new RenderTarget<PF_RGBA16F>( m_Device, "EnterMap Light", DEPTH_MAP_SIZE, DEPTH_MAP_SIZE, 1 ) );
			m_EnterMapCamera = ToDispose( new RenderTarget<PF_RGBA16F>( m_Device, "EnterMap Camera", DEPTH_MAP_SIZE, DEPTH_MAP_SIZE, 1 ) );
			m_ExitMapLight = ToDispose( new RenderTarget<PF_RGBA16F>( m_Device, "ExitMap Light", DEPTH_MAP_SIZE, DEPTH_MAP_SIZE, 1 ) );
			m_ExitMapCamera = ToDispose( new RenderTarget<PF_RGBA16F>( m_Device, "EXitMap Camera", DEPTH_MAP_SIZE, DEPTH_MAP_SIZE, 1 ) );

			//////////////////////////////////////////////////////////////////////////
			// Create test voxels at the center of the world

			// Create a mostly planar grid
			int	GRID_SIZE = 14;
			int	GRID_HEIGHT = 8;
// 			int	GRID_SIZE = 4;
// 			int	GRID_HEIGHT = 4;
			for ( int Z=0; Z < GRID_SIZE; Z++ )
				for ( int Y=0; Y < GRID_HEIGHT; Y++ )
					for ( int X=0; X < GRID_SIZE; X++ )
						CreateVoxel( -GRID_SIZE/2+X, Y, -GRID_SIZE/2+Z );
		}

		public override void	Render( int _FrameToken )
		{
			if ( m_Camera == null || m_Light == null )
				return;

			//////////////////////////////////////////////////////////////////////////
			// 1] Build uncomputed geometries
			m_Device.SetStockRasterizerState( Device.HELPER_STATES.NO_CULLING );
			m_Device.SetStockDepthStencilState( Device.HELPER_DEPTH_STATES.DISABLED );
			m_Device.SetStockBlendState( Device.HELPER_BLEND_STATES.DISABLED );

			if ( m_NotComputedVoxelsRoot != null )
			{
				//////////////////////////////////////////////////////////////////////////
				// 1.1] Compute density volumes for voxels
				using ( m_MaterialBuildDensity.UseLock() )
				{
					m_DensityQuadVB.Use();
					m_Device.InputAssembler.PrimitiveTopology = PrimitiveTopology.TriangleStrip;
 					m_Device.SetViewport( 0, 0, DENSITY_VOXEL_TEXTURE_SIZE, DENSITY_VOXEL_TEXTURE_SIZE, 0.0f, 1.0f );

					m_MaterialBuildDensity.GetVariableByName( "TextureSize" ).AsScalar.Set( DENSITY_VOXEL_TEXTURE_SIZE );
					m_MaterialBuildDensity.GetVariableByName( "BlockWorldSize" ).AsScalar.Set( VOXEL_BLOCK_SIZE );

					for ( int i=0; i < 8; i++ )
						m_MaterialBuildDensity.GetVariableByName( "octaveMat"+i ).AsMatrix.SetMatrix( m_RandomRotation[i] );

					m_MaterialBuildDensity.GetVariableByName( "PlaneDistance" ).AsScalar.Set( m_PlaneDistance );

					VariableVector	vBlockWorldPosition = m_MaterialBuildDensity.GetVariableByName( "BlockWorldPosition" ).AsVector;

					EffectPass	Pass = m_MaterialBuildDensity.CurrentTechnique.GetPassByIndex( 0 );

					int		VoxelIndex = 0;
					Voxel	Current = m_NotComputedVoxelsRoot;
					while ( Current != null && VoxelIndex < MAX_VOXELS_PER_FRAME )
					{
						// Render to our density volume
						m_Device.SetRenderTarget( m_DensityTextures[VoxelIndex] );

						vBlockWorldPosition.Set( Current.Position );

						Pass.Apply();

						// Render as many quad instances as voxel corners
						//	each instance will render in a different slice of the 3D target
						m_DensityQuadVB.DrawInstanced( DENSITY_VOXEL_TEXTURE_SIZE );

						Current = Current.Next;
						VoxelIndex++;
					}
				}

				//////////////////////////////////////////////////////////////////////////
				// 1.2] Build the geometry from the density volumes using marching cubes
 				using ( m_MaterialBuildGeometry.UseLock() )
				{
					m_VoxelSliceVB.Use();
					m_Device.InputAssembler.PrimitiveTopology = PrimitiveTopology.PointList;

					// Clear the render target otherwise it somewhat renders to the last 3D volume target
					// (even though we don't use a pixel shader with that material... strange)
					m_Device.OutputMerger.SetTargets( (DepthStencilView) null, (RenderTargetView) null );

					m_MaterialBuildGeometry.GetVariableByName( "TextureSize" ).AsScalar.Set( DENSITY_VOXEL_TEXTURE_SIZE );
					m_MaterialBuildGeometry.GetVariableByName( "InvTextureSize" ).AsVector.Set( new Vector2( 1.0f / DENSITY_VOXEL_TEXTURE_SIZE, 0.0f ) );
					m_MaterialBuildGeometry.GetVariableByName( "InvVoxelCellsCount" ).AsScalar.Set( 1.0f / VOXEL_CELLS_COUNT );
					m_MaterialBuildDensity.GetVariableByName( "BlockWorldSize" ).AsScalar.Set( VOXEL_BLOCK_SIZE );
					m_MaterialBuildGeometry.GetVariableByName( "BlockCellWorldSize" ).AsScalar.Set( VOXEL_BLOCK_SIZE / VOXEL_CELLS_COUNT );

					VariableVector		vBlockWorldPosition = m_MaterialBuildGeometry.GetVariableByName( "BlockWorldPosition" ).AsVector;
					VariableResource	vDensityTexture = m_MaterialBuildGeometry.GetVariableByName( "DensityVolumeTexture" ).AsResource;

					EffectPass	Pass = m_MaterialBuildGeometry.CurrentTechnique.GetPassByIndex( 0 );

					int		VoxelIndex = 0;
					while ( m_NotComputedVoxelsRoot != null && VoxelIndex < MAX_VOXELS_PER_FRAME )
					{
						Voxel	ComputedVoxel = m_NotComputedVoxelsRoot;

						vBlockWorldPosition.Set( ComputedVoxel.Position );
						vDensityTexture.SetResource( m_DensityTextures[VoxelIndex].TextureView );

						ComputedVoxel.Geometry.UseAsOutput();

						Pass.Apply();

//ComputedVoxel.Geometry.BeginQuery();

						// Draw "cells count" instances of a "cells count * cells count" array of points
						// Each point has an X,Y integer coordinate, the instance ID being the Z coordinate of the cell being drawn
						m_VoxelSliceVB.DrawInstanced( VOXEL_CELLS_COUNT );

//ComputedVoxel.Geometry.EndQuery( true );

						ComputedVoxel.Geometry.UnUse();	// VERY IMPORTANT LINE HERE ! (otherwise we would continue to render to a stream output)

						// Link the not-computed voxel root to the now computed voxels list
						m_NotComputedVoxelsRoot = m_NotComputedVoxelsRoot.Next;
						if ( m_NotComputedVoxelsRoot != null )
							m_NotComputedVoxelsRoot.Previous = null;

						if ( m_ComputedVoxelsRoot != null )
							m_ComputedVoxelsRoot.Previous = ComputedVoxel;
						ComputedVoxel.Next = m_ComputedVoxelsRoot;
						m_ComputedVoxelsRoot = ComputedVoxel;

						// One more computed voxel
						VoxelIndex++;
					}
				}
			}

			//////////////////////////////////////////////////////////////////////////
			// 2] Render depth maps
 			m_Device.SetStockRasterizerState( Device.HELPER_STATES.NO_CULLING );
			m_Device.SetStockDepthStencilState( Device.HELPER_DEPTH_STATES.DISABLED );
			m_Device.SetStockBlendState( Device.HELPER_BLEND_STATES.ADDITIVE );

			// 2.1] Compute cloud's AA bounding box
			BoundingBox	BBox = new BoundingBox( new Vector3( +float.MaxValue, +float.MaxValue, +float.MaxValue ), new Vector3( -float.MaxValue, -float.MaxValue, -float.MaxValue ) );
			{
				Voxel	Current = m_ComputedVoxelsRoot;
				while ( Current != null )
				{
					Vector3	PositionMin = Current.Position;
					Vector3	PositionMax = PositionMin + new Vector3( VOXEL_BLOCK_SIZE, VOXEL_BLOCK_SIZE, VOXEL_BLOCK_SIZE );

					BBox.Minimum.X = Math.Min( BBox.Minimum.X, PositionMin.X );
					BBox.Minimum.Y = Math.Min( BBox.Minimum.Y, PositionMin.Y );
					BBox.Minimum.Z = Math.Min( BBox.Minimum.Z, PositionMin.Z );
					BBox.Maximum.X = Math.Max( BBox.Maximum.X, PositionMax.X );
					BBox.Maximum.Y = Math.Max( BBox.Maximum.Y, PositionMax.Y );
					BBox.Maximum.Z = Math.Max( BBox.Maximum.Z, PositionMax.Z );

					Current = Current.Next;
				}
			}

			// 2.2] Compute cloud's projection matrces
			Vector3	BBoxCenter = 0.5f * (BBox.Minimum + BBox.Maximum);

			// 2.2.1] For the LIGHT
			Matrix	Light2World = Camera.CreateLookAt( BBoxCenter + m_Light.Direction, BBoxCenter, Vector3.UnitY );

			Matrix	World2Light = Light2World;
					World2Light.Invert();

			Vector3	ProjMin = new Vector3( +float.MaxValue, +float.MaxValue, +float.MaxValue );
			Vector3	ProjMax = new Vector3( -float.MaxValue, -float.MaxValue, -float.MaxValue );
			foreach ( Vector3 Corner in BBox.GetCorners() )
			{
				Vector3	CornerLight = Vector3.TransformCoordinate( Corner, World2Light );	// Corner position in LIGHT space
				ProjMin.X = Math.Min( ProjMin.X, CornerLight.X );
				ProjMin.Y = Math.Min( ProjMin.Y, CornerLight.Y );
				ProjMin.Z = Math.Min( ProjMin.Z, CornerLight.Z );
				ProjMax.X = Math.Max( ProjMax.X, CornerLight.X );
				ProjMax.Y = Math.Max( ProjMax.Y, CornerLight.Y );
				ProjMax.Z = Math.Max( ProjMax.Z, CornerLight.Z );
			}

			float	fScaleX = 2.0f / (ProjMax.X - ProjMin.X);
			float	fScaleY = 2.0f / (ProjMax.Y - ProjMin.Y);
			float	fScaleZ = 1.0f / (ProjMax.Z - ProjMin.Z);
			float	OffsetX = -0.5f * (ProjMin.X + ProjMax.X) * fScaleX;
			float	OffsetY = -0.5f * (ProjMin.Y + ProjMax.Y) * fScaleY;
			float	OffsetZ = -ProjMin.Z * fScaleZ;

			Matrix	Light2Proj = Matrix.Identity;
			Light2Proj.M11 = fScaleX;
			Light2Proj.M12 = 0.0f;
			Light2Proj.M13 = 0.0f;
			Light2Proj.M21 = 0.0f;
			Light2Proj.M22 = fScaleY;
			Light2Proj.M23 = 0.0f;
			Light2Proj.M31 = 0.0f;
			Light2Proj.M32 = 0.0f;
			Light2Proj.M33 = fScaleZ;
			Light2Proj.M41 = OffsetX;
			Light2Proj.M42 = OffsetY;
			Light2Proj.M43 = OffsetZ;
			Light2Proj.M44 = 1.0f;

			Matrix	World2LightProj = World2Light * Light2Proj;

 			// 2.2.2] For the CAMERA
			Matrix	Camera2World = m_Camera.Camera2World;
			Matrix	World2Camera = m_Camera.World2Camera;
			Matrix	World2CameraProj = m_Camera.World2Proj;

			Vector4	CameraPosition4 = Camera2World.Row4;
			Vector3	CameraPosition = new Vector3( CameraPosition4.X, CameraPosition4.Y, CameraPosition4.Z );

			using ( m_MaterialBuildDepthMaps.UseLock() )
			{
				// -------------------------------------------------------------------
				// 2.3] Render depth maps
				m_Device.InputAssembler.PrimitiveTopology = PrimitiveTopology.TriangleList;
				m_Device.SetViewport( 0, 0, DEPTH_MAP_SIZE, DEPTH_MAP_SIZE, 0.0f, 1.0f );

				Voxel	Current = null;
				EffectTechnique	TechDepth = null;
				EffectPass		Pass = null;

				// 2.3.1] From light's POV
				if ( m_bLightDirty )
				{
					TechDepth = m_MaterialBuildDepthMaps.GetTechniqueByName( "BuildDepthMapLight" );
					m_MaterialBuildDepthMaps.CurrentTechnique = TechDepth;
					Pass = TechDepth.GetPassByIndex( 0 );

					m_Device.SetRenderTarget( m_DepthMapLight );
					m_Device.ClearRenderTarget( m_DepthMapLight, (Color4) Vector4.Zero );

					m_MaterialBuildDepthMaps.GetVariableByName( "World2Proj" ).AsMatrix.SetMatrix( World2LightProj );
					m_MaterialBuildDepthMaps.GetVariableByName( "World2View" ).AsMatrix.SetMatrix( World2Light );

					Current = m_ComputedVoxelsRoot;
					while ( Current != null )
					{
						Current.Geometry.UseAsInput();
						Pass.Apply();
						Current.Geometry.Draw();
						Current = Current.Next;
					}
				}

				// 2.3.2] From camera's POV
				TechDepth = m_MaterialBuildDepthMaps.GetTechniqueByName( "BuildDepthMapCamera" );
				m_MaterialBuildDepthMaps.CurrentTechnique = TechDepth;
				Pass = TechDepth.GetPassByIndex( 0 );

				m_Device.SetRenderTarget( m_DepthMapCamera );
				m_Device.ClearRenderTarget( m_DepthMapCamera, (Color4) Vector4.Zero );

				m_MaterialBuildDepthMaps.GetVariableByName( "World2Proj" ).AsMatrix.SetMatrix( World2CameraProj );
				m_MaterialBuildDepthMaps.GetVariableByName( "World2View" ).AsMatrix.SetMatrix( World2Camera );
				m_MaterialBuildDepthMaps.GetVariableByName( "CameraPosition" ).AsVector.Set( Camera2World.Row4 );

				Current = m_ComputedVoxelsRoot;
				while ( Current != null )
				{
					Current.Geometry.UseAsInput();
					Pass.Apply();
					Current.Geometry.Draw();
					Current = Current.Next;
				}

				// -------------------------------------------------------------------
				// 2.4] Render depth entry maps
				m_Device.SetStockRasterizerState( Device.HELPER_STATES.CULL_BACK );			// Backface culling
				m_Device.SetStockDepthStencilState( Device.HELPER_DEPTH_STATES.WRITE_CLOSEST );	// Write closest
				m_Device.SetStockBlendState( Device.HELPER_BLEND_STATES.DISABLED );			// Disable blending

				TechDepth = m_MaterialBuildDepthMaps.GetTechniqueByName( "BuildDepthEntry" );
				m_MaterialBuildDepthMaps.CurrentTechnique = TechDepth;
				Pass = TechDepth.GetPassByIndex( 0 );

				// 2.4.1] Entry for LIGHT
				if ( m_bLightDirty )
				{
					m_Device.SetRenderTarget( m_EnterMapLight, m_DepthMapDepthStencil );
					m_Device.ClearRenderTarget( m_EnterMapLight, new Color4( float.PositiveInfinity, float.PositiveInfinity, float.PositiveInfinity, float.PositiveInfinity ) );
					m_Device.ClearDepthStencil( m_DepthMapDepthStencil, DepthStencilClearFlags.Depth, 1.0f, 0 );	// Clear to furthest

					m_MaterialBuildDepthMaps.GetVariableByName( "World2Proj" ).AsMatrix.SetMatrix( World2LightProj );

					Current = m_ComputedVoxelsRoot;
					while ( Current != null )
					{
						Current.Geometry.UseAsInput();
						Pass.Apply();
						Current.Geometry.Draw();
						Current = Current.Next;
					}
				}

				// 2.4.1] Entry for CAMERA
				m_Device.SetRenderTarget( m_EnterMapCamera, m_DepthMapDepthStencil );
				m_Device.ClearRenderTarget( m_EnterMapCamera, new Color4( float.PositiveInfinity, float.PositiveInfinity, float.PositiveInfinity, float.PositiveInfinity ) );
				m_Device.ClearDepthStencil( m_DepthMapDepthStencil, DepthStencilClearFlags.Depth, 1.0f, 0 );	// Clear to furthest

				m_MaterialBuildDepthMaps.GetVariableByName( "World2Proj" ).AsMatrix.SetMatrix( World2CameraProj );

				Current = m_ComputedVoxelsRoot;
				while ( Current != null )
				{
					Current.Geometry.UseAsInput();
					Pass.Apply();
					Current.Geometry.Draw();
					Current = Current.Next;
				}

				// -------------------------------------------------------------------
				// 2.5] Render depth exit maps
				m_Device.SetStockRasterizerState( Device.HELPER_STATES.CULL_FRONT );				// Frontface culling
				m_Device.SetStockDepthStencilState( Device.HELPER_DEPTH_STATES.WRITE_FARTHEST );	// Write farthest
				m_Device.SetStockBlendState( Device.HELPER_BLEND_STATES.DISABLED );					// Disable blending

				// 2.5.1] Exit for LIGHT
				if ( m_bLightDirty )
				{
					m_Device.SetRenderTarget( m_ExitMapLight, m_DepthMapDepthStencil );
					m_Device.ClearRenderTarget( m_ExitMapLight, new Color4( float.NegativeInfinity, float.NegativeInfinity, float.NegativeInfinity, float.NegativeInfinity ) );
					m_Device.ClearDepthStencil( m_DepthMapDepthStencil, DepthStencilClearFlags.Depth, 0.0f, 0 );	// Clear to closest

					m_MaterialBuildDepthMaps.GetVariableByName( "World2Proj" ).AsMatrix.SetMatrix( World2LightProj );

					Current = m_ComputedVoxelsRoot;
					while ( Current != null )
					{
						Current.Geometry.UseAsInput();
						Pass.Apply();
						Current.Geometry.Draw();
						Current = Current.Next;
					}
				}

				// 2.4.1] Exit for CAMERA
				m_Device.SetRenderTarget( m_ExitMapCamera, m_DepthMapDepthStencil );
				m_Device.ClearRenderTarget( m_ExitMapCamera, new Color4( float.NegativeInfinity, float.NegativeInfinity, float.NegativeInfinity, float.NegativeInfinity ) );
				m_Device.ClearDepthStencil( m_DepthMapDepthStencil, DepthStencilClearFlags.Depth, 0.0f, 0 );	// Clear to closest

				m_MaterialBuildDepthMaps.GetVariableByName( "World2Proj" ).AsMatrix.SetMatrix( World2CameraProj );

				Current = m_ComputedVoxelsRoot;
				while ( Current != null )
				{
					Current.Geometry.UseAsInput();
					Pass.Apply();
					Current.Geometry.Draw();
					Current = Current.Next;
				}
			}

			if ( m_NotComputedVoxelsRoot == null )
				m_bLightDirty = false;	// Light is now updated and all voxels have been computed...

			//////////////////////////////////////////////////////////////////////////
			// 3] Render visible voxels's density volumes
			m_Device.SetStockRasterizerState( Device.HELPER_STATES.CULL_BACK );
			m_Device.SetStockDepthStencilState( Device.HELPER_DEPTH_STATES.WRITE_CLOSEST );
			m_Device.SetStockBlendState( Device.HELPER_BLEND_STATES.DISABLED );

			using ( m_MaterialDisplayVoxel.UseLock() )
			{
				m_Device.InputAssembler.PrimitiveTopology = PrimitiveTopology.TriangleList;
				m_Device.SetDefaultRenderTarget();

				CurrentMaterial.GetVariableByName( "World2LightProj" ).AsMatrix.SetMatrix( World2LightProj );
				CurrentMaterial.GetVariableByName( "World2Light" ).AsMatrix.SetMatrix( World2Light );
				CurrentMaterial.GetVariableByName( "TextureDepthLight" ).AsResource.SetResource( m_DepthMapLight.TextureView );
				CurrentMaterial.GetVariableByName( "TextureEnterLight" ).AsResource.SetResource( m_EnterMapLight.TextureView );
				CurrentMaterial.GetVariableByName( "TextureExitLight" ).AsResource.SetResource( m_ExitMapLight.TextureView );
				CurrentMaterial.GetVariableByName( "TextureDepthCamera" ).AsResource.SetResource( m_DepthMapCamera.TextureView );
				CurrentMaterial.GetVariableByName( "TextureEnterCamera" ).AsResource.SetResource( m_EnterMapCamera.TextureView );
				CurrentMaterial.GetVariableByName( "TextureExitCamera" ).AsResource.SetResource( m_ExitMapCamera.TextureView );

				CurrentMaterial.GetVariableByName( "TextureScattering0" ).AsResource.SetResource( m_ScatteringTable0.TextureView );
				CurrentMaterial.GetVariableByName( "TextureScattering1" ).AsResource.SetResource( m_ScatteringTable1.TextureView );
				CurrentMaterial.GetVariableByName( "TextureScattering2" ).AsResource.SetResource( m_ScatteringTable2.TextureView );
				CurrentMaterial.GetVariableByName( "TexturePhase" ).AsResource.SetResource( m_PhaseTable.TextureView );

				Vector4[]	LightSHCoeffs = new Vector4[9];
				BuildLightSHCoefficients( LightSHCoeffs, 0.25 * Math.PI, m_Light.Direction );
				CurrentMaterial.GetVariableByName( "SHLight" ).AsVector.Set( LightSHCoeffs );

				Vector4[]	LightSHCoeffsReversed = new Vector4[9];
				BuildLightSHCoefficients( LightSHCoeffsReversed, 0.25 * Math.PI, -m_Light.Direction );
				CurrentMaterial.GetVariableByName( "SHLightReversed" ).AsVector.Set( LightSHCoeffsReversed );

				Matrix	World2CameraSH = World2Camera;
						World2CameraSH.Row3 = -World2Camera.Row3;	// Reverse Z
				CurrentMaterial.GetVariableByName( "World2CameraSH" ).AsMatrix.SetMatrix( World2CameraSH );


				EffectPass	Pass0 = CurrentMaterial.CurrentTechnique.GetPassByIndex( 0 );	// Core geometry pass
				EffectPass	Pass1 = CurrentMaterial.CurrentTechnique.GetPassByIndex( 1 );	// Silhouette pass

				Voxel	Current = m_ComputedVoxelsRoot;
				while ( Current != null )
				{
					Current.Geometry.UseAsInput();

					// Draw geometry
					Pass0.Apply();
					Current.Geometry.Draw();

					// Draw silhouette
// 					Pass1.Apply();
// 					Current.Geometry.Draw();

					Current = Current.Next;
				}
			}
		}

		public Voxel	CreateVoxel( int _PosX, int _PosY, int _PosZ )
		{
			Voxel	Result = null;
			if ( m_AvailableVoxelsRoot != null )
			{	// Re-use one of the available voxels
				Result = m_AvailableVoxelsRoot;
				m_AvailableVoxelsRoot = m_AvailableVoxelsRoot.Next;
				if ( m_AvailableVoxelsRoot != null )
					m_AvailableVoxelsRoot.Previous = null;
			}
			else
			{	// Create a brand new one
				Result = new Voxel( this, VOXEL_CELLS_COUNT, VOXEL_BLOCK_SIZE );
			}

			// Initialize its position
			Result.BlockPositionX = _PosX;
			Result.BlockPositionY = _PosY;
			Result.BlockPositionZ = _PosZ;

			// Link it to the existing not voxels
			Result.Previous = null;
			Result.Next = m_NotComputedVoxelsRoot;
			if ( m_NotComputedVoxelsRoot != null )
				m_NotComputedVoxelsRoot.Previous = Result;
			m_NotComputedVoxelsRoot = Result;

			return Result;
		}

		public void		DeleteVoxel( Voxel _Voxel )
		{
			// Link over it
			if ( _Voxel.Previous != null )
				_Voxel.Previous = _Voxel.Next;
			else
			{	// The voxel may either be in the computed or not-computed list
				if ( _Voxel == m_ComputedVoxelsRoot )
					m_ComputedVoxelsRoot = _Voxel.Next;
				else
					m_NotComputedVoxelsRoot = _Voxel.Next;
			}

			if ( _Voxel.Next != null )
				_Voxel.Next = _Voxel.Previous;

			// Link it to the now available voxels
			_Voxel.Previous = null;
			_Voxel.Next = m_AvailableVoxelsRoot;
			if ( m_AvailableVoxelsRoot != null )
				m_AvailableVoxelsRoot.Previous = _Voxel;

			m_AvailableVoxelsRoot = _Voxel;
		}

		public void		ClearVoxelGeometries()
		{
			while ( m_ComputedVoxelsRoot != null )
			{
				Voxel	Current = m_ComputedVoxelsRoot;

				// Link computed voxel root to next voxel in line
				Current.Previous = null;
				m_ComputedVoxelsRoot = Current.Next;
				if ( m_ComputedVoxelsRoot != null )
					m_ComputedVoxelsRoot.Previous = null;

				// Link the previous computed root to the not-computed list
				if ( m_NotComputedVoxelsRoot != null )
					m_NotComputedVoxelsRoot.Previous = Current;
				Current.Next = m_NotComputedVoxelsRoot;
				m_NotComputedVoxelsRoot = Current;
			}
		}

		/// <summary>
		/// Loads the scattering table pre-computed by the CloudPreComputer project
		/// This table will be stored as 3 half-precision floats 3D textures that
		///  will contain 4, 4 and 1 values respectively for a total of 9 monochromatic SH coefficients
		/// </summary>
		protected void	LoadScatteringTable()
		{
			// Build the volume filled with SH coefficients
			SHVector[,,]	Table = new SHVector[SLAB_TEXTURE_SIZE,SLAB_TEXTURE_SIZE,SLAB_TEXTURE_DEPTH];

			// Read table from disk
//			System.IO.FileInfo		ScatoFile = new System.IO.FileInfo( @"..\Tools\CloudPreComputer\Tables\Scattering1.sh" );
			System.IO.FileInfo		ScatoFile = new System.IO.FileInfo( @"..\Tools\CloudPreComputer\Tables\AccumulatedScattering.sh" );
			System.IO.FileStream	Stream = ScatoFile.OpenRead();
			System.IO.BinaryReader	Reader = new System.IO.BinaryReader( Stream );

			for ( int X=0; X < SLAB_TEXTURE_SIZE; X++ )
				for ( int Y=0; Y < SLAB_TEXTURE_SIZE; Y++ )
					for ( int Z=0; Z < SLAB_TEXTURE_DEPTH; Z++ )
					{
						SHVector	V =  new SHVector();
						V.Read( Reader );
						Table[X,Y,Z] = V;
					}
			Reader.Close();
			Reader.Dispose();

			// Build the actual textures
			// We create 2 textures containing each 8 coefficients
			// 
			using ( Image3D<PF_RGBA16F> Image = new Image3D<PF_RGBA16F>( m_Device, "ScatteringImage0", SLAB_TEXTURE_SIZE, SLAB_TEXTURE_SIZE, SLAB_TEXTURE_DEPTH,
				( int _X, int _Y, int _Z, ref Vector4 _Color ) =>
				{	// First table encodes the first 4 coefficients
					SHVector	SHCoeffs = Table[_X,_Y,_Z];
					_Color.X = (float) SHCoeffs.V[0];
					_Color.Y = (float) SHCoeffs.V[1];
					_Color.Z = (float) SHCoeffs.V[2];
					_Color.W = (float) SHCoeffs.V[3];
				}, 1 ) )
			{
				m_ScatteringTable0 = ToDispose( new Texture3D<PF_RGBA16F>( m_Device, "Scattering0", Image ) );
			}

			using ( Image3D<PF_RGBA16F> Image = new Image3D<PF_RGBA16F>( m_Device, "ScatteringImage1", SLAB_TEXTURE_SIZE, SLAB_TEXTURE_SIZE, SLAB_TEXTURE_DEPTH,
				( int _X, int _Y, int _Z, ref Vector4 _Color ) =>
				{	// Second table encodes the next 4 coefficients
					SHVector	SHCoeffs = Table[_X,_Y,_Z];
					_Color.X = (float) SHCoeffs.V[4];
					_Color.Y = (float) SHCoeffs.V[5];
					_Color.Z = (float) SHCoeffs.V[6];
					_Color.W = (float) SHCoeffs.V[7];
				}, 1 ) )
			{
				m_ScatteringTable1 = ToDispose( new Texture3D<PF_RGBA16F>( m_Device, "Scattering1", Image ) );
			}

			// And one final texture containing the last coefficient
			using ( Image3D<PF_R16F> Image = new Image3D<PF_R16F>( m_Device, "ScatteringImage2", SLAB_TEXTURE_SIZE, SLAB_TEXTURE_SIZE, SLAB_TEXTURE_DEPTH,
				( int _X, int _Y, int _Z, ref Vector4 _Color ) =>
				{	// Third table encodes the last coefficient
					SHVector	SHCoeffs = Table[_X,_Y,_Z];
					_Color.X = (float) SHCoeffs.V[8];
				}, 1 ) )
			{
				m_ScatteringTable2 = ToDispose( new Texture3D<PF_R16F>( m_Device, "Scattering2", Image ) );
			}
		}

		/// <summary>
		/// Builds the table containing the Mie phase function
		/// </summary>
		protected void	BuildPhaseFunction()
		{
			Atmospheric.PhaseFunction	PhaseFunction = new Atmospheric.PhaseFunction();
			PhaseFunction.Init( Atmospheric.CloudPhase.CloudPhaseFunction.MIE_PHASE_FUNCTION, 0.0f, (float) Math.PI, PHASE_TEXTURE_LENGTH );

			using ( Image<PF_R16F> Image = new Image<PF_R16F>( m_Device, "PhaseImage", PHASE_TEXTURE_LENGTH, 1,
				( int _X, int _Y, ref Vector4 _Color ) =>
				{	// Third table encodes the last coefficient
					_Color.X = (float) PhaseFunction.GetPhaseFactor( (float) Math.PI * _X / (PHASE_TEXTURE_LENGTH-1) );
				}, 1 ) )
			{
				m_PhaseTable = ToDispose( new Texture2D<PF_R16F>( m_Device, "Phase", Image ) );
			}
		}

		protected void	TestAnalyticalSH()
		{
			// Compute SH coefficients for that direction
			WMath.Vector	Normal = new WMath.Vector( m_Light.Direction.Z, -m_Light.Direction.X, m_Light.Direction.Y );
			double[]	SH = new double[9];
			double	RSqPI = 0.5 / Math.Sqrt(Math.PI);
			SH[0] = RSqPI;
			double	f0 = Math.Sqrt(3.0) * RSqPI;
			SH[1] = -f0 * Normal.y;
			SH[2] = f0 * Normal.z;
			SH[3] = -f0 * Normal.x;
			double	f1 = Math.Sqrt(15.0) * RSqPI;
			SH[4] = f1 * Normal.y * Normal.x;
			SH[5] = -f1 * Normal.y * Normal.z;
			SH[6] = f1 / (2.0 * Math.Sqrt(3.0)) * (3.0 * Normal.z*Normal.z - 1.0);
			SH[7] = -f1 * Normal.x * Normal.z;
			SH[8] = f1 * 0.5 * (Normal.x*Normal.x - Normal.y*Normal.y);


			Normal = new WMath.Vector( m_Light.Direction.X, m_Light.Direction.Y, m_Light.Direction.Z );
			double[]	SH2 = new double[9];
			SphericalHarmonics.SHFunctions.InitializeSHCoefficients( 3, Normal, SH2 );

		}

		protected double[]	TestSamplingSH( Vector3 _LightDirection )
		{
			// Try and get the SH coefficients by sampling the sphere of directions
			SphericalHarmonics.SHSamplesCollection	Samples = new SphericalHarmonics.SHSamplesCollection( 1 );
			Samples.Initialize( 3, 40 );

			double[]	SH = Samples.Project( ( WMath.Vector _Direction, double _Phi, double _Theta ) =>
				{
					double	Dot = _LightDirection.X * _Direction.x
								+ _LightDirection.Y * _Direction.y
								+ _LightDirection.Z * _Direction.z;
					Dot = Math.Max( 0.0, Dot );

					return Dot;
				} );

			return SH;
		}

		/// <summary>
		/// Builds the SH coefficients for a cutoff light aligned in the direction of the Sun
		/// NOTE: The SH coefficients are in CAMERA space
		/// </summary>
		/// <param name="_SHCoeffs"></param>
		/// <param name="_Cutoff">Cutoff angle off the Y axis</param>
		/// <param name="_LightDirection">Light direction (pointing toward the light)</param>
		protected void	BuildLightSHCoefficients( Vector4[] _SHCoeffs, double _Cutoff, Vector3 _LightDirection )
		{
			double[]	ZH = new double[3];

//TestAnalyticalSH();

			// Symbolic integration automatically generated by Maple.
			double t3 = (-_Cutoff + Math.PI) > 0.0 ? 1.0 : 0.0;
			double t5 = Math.Cos(_Cutoff);
			double t6 = t3*t5;
			double t9 = (-_Cutoff) > 0.0 ? 1.0 : 0.0;
			double t11 = t9*t5;
			double t14 = Math.Sin(_Cutoff);
			double t15 = t14*t14;
			double t16 = t3*t15;
			double t18 = t9*t15;
			double t21 = t5*t5;
			double t22 = t21*t5;
			double t31 = t21*t21;
			ZH[0] = 3.544907702 - 1.772453851*t3 - 1.772453851*t6 - 1.772453851*t9 + 1.772453851*t11;
			ZH[1] = 1.534990062*t16 - 1.534990062*t18;
			ZH[2] = -1.98166365*t3*t22 + 1.98166365*t6 + 1.98166365*t9*t22 - 1.98166365*t11;
//			ZH[3] = 2.930920062*t3 - 2.930920062*t3*t31 - 3.517104075*t16 - 2.930920062*t9 + 2.930920062*t9*t31 + 3.517104075*t18;

			// Rotate ZH toward actual light direction
			double[]	SH = new double[9];
			SphericalHarmonics.SHFunctions.ComputeRotatedZHCoefficients( ZH, new WMath.Vector( _LightDirection.X, _LightDirection.Y, _LightDirection.Z ), SH );


//double[]	SH2 = TestSamplingSH( _LightDirection );
//			SH = TestSamplingSH( _LightDirection );



			// Transform into CAMERA space
			WMath.Matrix3x3	World2Camera3x3 = new WMath.Matrix3x3();
			World2Camera3x3.SetRow0( new WMath.Vector( m_Camera.Camera2World.M11, m_Camera.Camera2World.M12, m_Camera.Camera2World.M13 ) );
			World2Camera3x3.SetRow1( new WMath.Vector( m_Camera.Camera2World.M21, m_Camera.Camera2World.M22, m_Camera.Camera2World.M23 ) );
			World2Camera3x3.SetRow2( -new WMath.Vector( m_Camera.Camera2World.M31, m_Camera.Camera2World.M32, m_Camera.Camera2World.M33 ) );
			World2Camera3x3.Invert();
//			World2Camera3x3.MakeIdentity();

			double[]	CameraSH = new double[9];
			double[,]	World2Camera = new double[9,9];
			SphericalHarmonics.SHFunctions.BuildRotationMatrix( World2Camera3x3, World2Camera, 3 );
			SphericalHarmonics.SHFunctions.Rotate( SH, World2Camera, CameraSH, 3 );

			// Finalize
			Color4	Ambient = (Color4) System.Drawing.Color.CornflowerBlue;
			_SHCoeffs[0].X += Ambient.Red;
			_SHCoeffs[0].Y += Ambient.Green;
			_SHCoeffs[0].Z += Ambient.Blue;

			for ( int i=0; i < 9; i++ )
			{
				_SHCoeffs[i].X += (float) (m_Light.Color.X * CameraSH[i]);
				_SHCoeffs[i].Y += (float) (m_Light.Color.Y * CameraSH[i]);
				_SHCoeffs[i].Z += (float) (m_Light.Color.Z * CameraSH[i]);
			}
		}

		#region Perlin Noise (stolen from http://staffwww.itn.liu.se/~stegu/aqsis/aqsis-newnoise/)

		//---------------------------------------------------------------------
		// 3D float Perlin periodic noise.
		//
		protected float	NoisePeriodic( float x, float y, float z, int px, int py, int pz )
		{
			int ix0, iy0, ix1, iy1, iz0, iz1;
			float fx0, fy0, fz0, fx1, fy1, fz1;
			float s, t, r;
			float nxy0, nxy1, nx0, nx1, n0, n1;

			ix0 = (int) Math.Floor( x );	// Integer part of x
			iy0 = (int) Math.Floor( y );	// Integer part of y
			iz0 = (int) Math.Floor( z );	// Integer part of z
			fx0 = x - ix0;					// Fractional part of x
			fy0 = y - iy0;					// Fractional part of y
			fz0 = z - iz0;					// Fractional part of z
			fx1 = fx0 - 1.0f;
			fy1 = fy0 - 1.0f;
			fz1 = fz0 - 1.0f;
			ix1 = (( ix0 + 1 ) % px ) & 0xff; // Wrap to 0..px-1 and wrap to 0..255
			iy1 = (( iy0 + 1 ) % py ) & 0xff; // Wrap to 0..py-1 and wrap to 0..255
			iz1 = (( iz0 + 1 ) % pz ) & 0xff; // Wrap to 0..pz-1 and wrap to 0..255
			ix0 = ( ix0 % px ) & 0xff;
			iy0 = ( iy0 % py ) & 0xff;
			iz0 = ( iz0 % pz ) & 0xff;
    
			r = FADE( fz0 );
			t = FADE( fy0 );
			s = FADE( fx0 );

			nxy0 = grad(ms_PermutationTable[ix0 + ms_PermutationTable[iy0 + ms_PermutationTable[iz0]]], fx0, fy0, fz0);
			nxy1 = grad(ms_PermutationTable[ix0 + ms_PermutationTable[iy0 + ms_PermutationTable[iz1]]], fx0, fy0, fz1);
			nx0 = LERP( r, nxy0, nxy1 );

			nxy0 = grad(ms_PermutationTable[ix0 + ms_PermutationTable[iy1 + ms_PermutationTable[iz0]]], fx0, fy1, fz0);
			nxy1 = grad(ms_PermutationTable[ix0 + ms_PermutationTable[iy1 + ms_PermutationTable[iz1]]], fx0, fy1, fz1);
			nx1 = LERP( r, nxy0, nxy1 );

			n0 = LERP( t, nx0, nx1 );

			nxy0 = grad(ms_PermutationTable[ix1 + ms_PermutationTable[iy0 + ms_PermutationTable[iz0]]], fx1, fy0, fz0);
			nxy1 = grad(ms_PermutationTable[ix1 + ms_PermutationTable[iy0 + ms_PermutationTable[iz1]]], fx1, fy0, fz1);
			nx0 = LERP( r, nxy0, nxy1 );

			nxy0 = grad(ms_PermutationTable[ix1 + ms_PermutationTable[iy1 + ms_PermutationTable[iz0]]], fx1, fy1, fz0);
			nxy1 = grad(ms_PermutationTable[ix1 + ms_PermutationTable[iy1 + ms_PermutationTable[iz1]]], fx1, fy1, fz1);
			nx1 = LERP( r, nxy0, nxy1 );

			n1 = LERP( t, nx0, nx1 );
    
			return 0.936f * ( LERP( s, n0, n1 ) );
		}

		//---------------------------------------------------------------------
		// This implementation is "Simplex Noise" as presented by
		// Ken Perlin at a relatively obscure and not often cited course
		// session "Real-Time Shading" at Siggraph 2001 (before real
		// time shading actually took on), under the title "hardware noise".
		// The 3D function is numerically equivalent to his Java reference
		// code available in the PDF course notes, although I re-implemented
		// it from scratch to get more readable code. The 1D, 2D and 4D cases
		// were implemented from scratch by me from Ken Perlin's text.
		// 
		protected float NoiseSimplex( float x, float y, float z )
		{
			// Simple skewing factors for the 3D case
			const float F3 = 0.333333333f;
			const float G3 = 0.166666667f;

			float n0, n1, n2, n3;	// Noise contributions from the four corners

			// Skew the input space to determine which simplex cell we're in
			float s = (x+y+z)*F3;	// Very nice and simple skew factor for 3D
			float xs = x+s;
			float ys = y+s;
			float zs = z+s;
			int i = (int) Math.Floor(xs);
			int j = (int) Math.Floor(ys);
			int k = (int) Math.Floor(zs);

			float t = (float)(i+j+k)*G3; 
			float X0 = i-t;			// Unskew the cell origin back to (x,y,z) space
			float Y0 = j-t;
			float Z0 = k-t;
			float x0 = x-X0;		// The x,y,z distances from the cell origin
			float y0 = y-Y0;
			float z0 = z-Z0;

			// For the 3D case, the simplex shape is a slightly irregular tetrahedron.
			// Determine which simplex we are in.
			int i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords
			int i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords

			/* This code would benefit from a backport from the GLSL version! */
			if(x0>=y0)
			{
				if(y0>=z0)
				{ i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; } // X Y Z order
				else if(x0>=z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; } // X Z Y order
				else { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; } // Z X Y order
			}
			else // x0<y0
			{
				if(y0<z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; } // Z Y X order
				else if(x0<z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; } // Y Z X order
				else { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; } // Y X Z order
			}

			// A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),
			// a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and
			// a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where
			// c = 1/6.

			float x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords
			float y1 = y0 - j1 + G3;
			float z1 = z0 - k1 + G3;
			float x2 = x0 - i2 + 2.0f*G3; // Offsets for third corner in (x,y,z) coords
			float y2 = y0 - j2 + 2.0f*G3;
			float z2 = z0 - k2 + 2.0f*G3;
			float x3 = x0 - 1.0f + 3.0f*G3; // Offsets for last corner in (x,y,z) coords
			float y3 = y0 - 1.0f + 3.0f*G3;
			float z3 = z0 - 1.0f + 3.0f*G3;

			// Wrap the integer indices at 256, to avoid indexing ms_PermutationTable[] out of bounds
			int ii = i & 0xFF;
			int jj = j & 0xFF;
			int kk = k & 0xFF;

			// Calculate the contribution from the four corners
			float t0 = 0.6f - x0*x0 - y0*y0 - z0*z0;
			if(t0 < 0.0f) n0 = 0.0f;
			else {
				t0 *= t0;
				n0 = t0 * t0 * grad(ms_PermutationTable[ii+ms_PermutationTable[jj+ms_PermutationTable[kk]]], x0, y0, z0);
			}

			float t1 = 0.6f - x1*x1 - y1*y1 - z1*z1;
			if(t1 < 0.0f) n1 = 0.0f;
			else {
				t1 *= t1;
				n1 = t1 * t1 * grad(ms_PermutationTable[ii+i1+ms_PermutationTable[jj+j1+ms_PermutationTable[kk+k1]]], x1, y1, z1);
			}

			float t2 = 0.6f - x2*x2 - y2*y2 - z2*z2;
			if(t2 < 0.0f) n2 = 0.0f;
			else {
				t2 *= t2;
				n2 = t2 * t2 * grad(ms_PermutationTable[ii+i2+ms_PermutationTable[jj+j2+ms_PermutationTable[kk+k2]]], x2, y2, z2);
			}

			float t3 = 0.6f - x3*x3 - y3*y3 - z3*z3;
			if(t3<0.0f) n3 = 0.0f;
			else {
				t3 *= t3;
				n3 = t3 * t3 * grad(ms_PermutationTable[ii+1+ms_PermutationTable[jj+1+ms_PermutationTable[kk+1]]], x3, y3, z3);
			}

			// Add contributions from each corner to get the final noise value.
			// The result is scaled to stay just inside [-1,1]
			return 32.0f * (n0 + n1 + n2 + n3); // TODO: The scale factor is preliminary!
		}

		protected float	LERP( float t, float x0, float x1 )
		{
			return (1.0f-t) * x0 + t * x1;
		}

		// This is the new and improved, C(2) continuous interpolant
		protected float FADE( float t )
		{
			return t * t * t * ( t * ( t * 6 - 15 ) + 10 );
		}

		// Helper functions to compute gradients-dot-residualvectors (1D to 4D)
		// Note that these generate gradients of more than unit length. To make
		// a close match with the value range of classic Perlin noise, the final
		// noise values need to be rescaled. To match the RenderMan noise in a
		// statistical sense, the approximate scaling values (empirically
		// determined from test renderings) are:
		// 1D noise needs rescaling with 0.188
		// 2D noise needs rescaling with 0.507
		// 3D noise needs rescaling with 0.936
		// 4D noise needs rescaling with 0.87
		// Note that these noise functions are the most practical and useful
		// signed version of Perlin noise. To return values according to the
		// RenderMan specification from the SL noise() and pnoise() functions,
		// the noise values need to be scaled and offset to [0,1], like this:
		// float SLnoise = (noise(x,y,z) + 1.0) * 0.5;
		//
		protected float  grad( int hash, float x, float y , float z )
		{
			int h = hash & 0xF;		// Convert low 4 bits of hash code into 12 simple
			float u = h<8 ? x : y;	// gradient directions, and compute dot product.
			float v = h<4 ? y : ((h==12 || h==14) ? x : z); // Fix repeats at h = 12 to 15
			return ((h&1) != 0 ? -u : u) + ((h&2) != 0 ? -v : v);
		}

		// Permutation table. This is just a random jumble of all numbers 0-255,
		// repeated twice to avoid wrapping the index at 255 for each lookup.
		// This needs to be exactly the same for all instances on all platforms,
		// so it's easiest to just keep it as static explicit data.
		// This also removes the need for any initialisation of this class.
		//
		// Note that making this an int[] instead of a char[] might make the
		// code run faster on platforms with a high penalty for unaligned single
		// byte addressing. Intel x86 is generally single-byte-friendly, but
		// some other CPUs are faster with 4-aligned reads.
		// However, a char[] is smaller, which avoids cache trashing, and that
		// is probably the most important aspect on most architectures.
		// This array is accessed a *lot* by the noise functions.
		// A vector-valued noise over 3D accesses it 96 times, and a
		// float-valued 4D noise 64 times. We want this to fit in the cache!
		//
		protected byte[]	ms_PermutationTable = new byte[2*256]
		{
		  151,160,137,91,90,15,
		  131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,
		  190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,
		  88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,
		  77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,
		  102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,
		  135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,
		  5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,
		  223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,
		  129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,
		  251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,
		  49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,
		  138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180,

		  151,160,137,91,90,15,
		  131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,
		  190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,
		  88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,
		  77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,
		  102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,
		  135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,
		  5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,
		  223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,
		  129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,
		  251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,
		  49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,
		  138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180
		};

		#endregion

		public void		UpdateLight()
		{
			m_bLightDirty = true;
		}

		#endregion

		#region EVENT HANDLERS

		#endregion
	}
}
