// Renders the volume mesh with back to front slices as in http://www.antisphere.com/Research/VolumetricBillboards.php
//
#include "../Camera.Fx"
#include "../Samplers.fx"

float4		BufferInvSize;
float3		VolumeSize;
float3		VolumeInvSize;
Texture3D	DiffuseAlpha;
Texture3D	Normal;

bool		PreMultiplyByAlpha;

static const float3	ToLight = float3( 0.57735, 0.57735, 0.57735 );


// The 8 BBox corners.
// Order is :
//
//      ^ Y
//      |
//      4-----5
//     /:    /|
//    / :   / |
//   0-----1  |
//   |  7..|..6--> X
//   | .   | /
//   |.    |/
//   3-----2
//  /
// |/ Z
//
// This box is then cut into 2 triangular prisms by the GS :
// First prism :
//  Bottom = 7 3 2
//  Top    = 4 0 1
//
// Second prism :
//  Bottom = 7 2 6
//  Top    = 4 1 5
//
float4		BBox[8];

float4		BBoxMinMax;			// XY=MinXY ZW=MaxXY in camera space
float4x4	Camera2BBoxUVW;		// Transforms a camera space position into a UVW for BBox mapping

static const float3	BBoxUVW[8] =
{
	float3( 0, 0, 1 ), float3( 1, 0, 1 ), float3( 1, 1, 1 ), float3( 0, 1, 1 ),
	float3( 0, 0, 0 ), float3( 1, 0, 0 ), float3( 1, 1, 0 ), float3( 0, 1, 0 ),
};

struct VS_IN
{
	float2	DepthMip	: TEXCOORD0;
};

struct PS_IN
{
	float4	Position	: SV_POSITION;
	float3	UVW			: TEXCOORD0;
	float	MipLevel	: MIPLEVEL;
};

VS_IN VS( VS_IN _In )	{ return _In; }

// ===================================================================================
// The GS "simply" cuts 2 triangular prisms issued from the BBox

// Computes the intersection of the given segment with the plane at specified Z
//
void	Intersect( float4 _P0, float4 _P1, float3 _UVW0, float3 _UVW1, float _Z, inout PS_IN _Out )
{
	float	t = (_Z - _P0.z) / (_P1.z - _P0.z);
	_Out.Position = mul( lerp( _P0, _P1, t ), Camera2Proj );	// Directly project
	_Out.UVW = lerp( _UVW0, _UVW1, t );
}

// Cuts a CAMERA space prism using a plane at specified Z
// The _FUCK extension is there because this GS doesn't work as the compiler seems to fuck up its predicted path and believes
//	some cases won't fill all the necessary data. Which I personnally think is bullshit but hey !
// There's a second version of CutPrism where all the cases were generated by a little piece of code.
//
void	CutPrism_FUCK( float4 _TriangleBottom[3], float4 _TriangleTop[3], float3 _UVWBottom[3], float3 _UVWTop[3], float _Z, float _MipLevel, inout TriangleStream<PS_IN> _Stream )
{
	// Compute the intersections of the plane with the 3 vertical lines joining the bottom and top triangles
	float	s[] =
	{
		(_Z - _TriangleBottom[0].z) / (_TriangleTop[0].z - _TriangleBottom[0].z),
		(_Z - _TriangleBottom[1].z) / (_TriangleTop[1].z - _TriangleBottom[1].z),
		(_Z - _TriangleBottom[2].z) / (_TriangleTop[2].z - _TriangleBottom[2].z)
	};

	// Obvious rejection
	if ( s[0] < 0.0 && s[1] < 0.0 && s[2] < 0.0 )
		return;
	if ( s[0] > 1.0 && s[1] > 1.0 && s[2] > 1.0 )
		return;

	int		Next[] = { 1, 2, 0, 1 };
	PS_IN	Out[5];
	Out[0].Position = 0.0;
	Out[0].UVW = 0.0;
	Out[0].MipLevel = _MipLevel;
	Out[1].Position = 0.0;
	Out[1].UVW = 0.0;
	Out[1].MipLevel = _MipLevel;
	Out[2].Position = 0.0;
	Out[2].UVW = 0.0;
	Out[2].MipLevel = _MipLevel;
	Out[3].Position = 0.0;
	Out[3].UVW = 0.0;
	Out[3].MipLevel = _MipLevel;
	Out[4].Position = 0.0;
	Out[4].UVW = 0.0;
	Out[4].MipLevel = _MipLevel;

	int		ResultCount = 0;

	[unroll]
	for ( int k=0; k < 3; k++ )
	{
		int	kleft = Next[k+1];
		int	kright = Next[k];

		if ( s[k] < 0.0 )
		{	// Emit 2 vertices in the bottom triangle
			if ( s[kleft] >= 0.0 )
				Intersect( _TriangleBottom[k], _TriangleBottom[kleft], _UVWBottom[k], _UVWBottom[kleft], _Z, Out[ResultCount++] );
			else
//			if ( s[kright] >= 0.0 )
				Intersect( _TriangleBottom[k], _TriangleBottom[kright], _UVWBottom[k], _UVWBottom[kright], _Z, Out[ResultCount++] );
		}
		else if ( s[k] > 1.0 )
		{	// Emit 2 vertices in the top triangle
			if ( s[kleft] <= 1.0 )
				Intersect( _TriangleTop[k], _TriangleTop[kleft], _UVWTop[k], _UVWTop[kleft], _Z, Out[ResultCount++] );
			else
//			if ( s[kright] <= 1.0 )
				Intersect( _TriangleTop[k], _TriangleTop[kright], _UVWTop[k], _UVWTop[kright], _Z, Out[ResultCount++] );
		}
		else
		{	// Emit a single vertex
			Intersect( _TriangleBottom[k], _TriangleTop[k], _UVWBottom[k], _UVWTop[k], _Z, Out[ResultCount++] );
		}
	}

	if ( ResultCount == 3 )
	{	// Emits only 1 triangle
		_Stream.Append( Out[0] );
		_Stream.Append( Out[1] );
		_Stream.Append( Out[2] );
	}
	else if ( ResultCount > 3 )
	{	// Emit 2 triangles as a single strip
		_Stream.Append( Out[1] );
		_Stream.Append( Out[0] );
		_Stream.Append( Out[2] );
		// 2nd triangle
		_Stream.Append( Out[3] );
	}

	if ( ResultCount < 5 )
		return;

	// The last triangle cannot be part of the strip, we need to re-emit a new strip altogether...
	_Stream.RestartStrip();
	_Stream.Append( Out[0] );
	_Stream.Append( Out[3] );
	_Stream.Append( Out[4] );
}


// Cuts a CAMERA space prism using a plane at specified Z
// Because a bug in the GS compiler, I had to strip out every fucking single possible fucking case of fucking intersections !
//
void	CutPrism( float4 _TriangleBottom[3], float4 _TriangleTop[3], float3 _UVWBottom[3], float3 _UVWTop[3], float _Z, float _MipLevel, inout TriangleStream<PS_IN> _Stream )
{
	// Compute the intersections of the plane with the 3 vertical lines joining the bottom and top triangles
	float	s[] =
	{
		(_Z - _TriangleBottom[0].z) / (_TriangleTop[0].z - _TriangleBottom[0].z),
		(_Z - _TriangleBottom[1].z) / (_TriangleTop[1].z - _TriangleBottom[1].z),
		(_Z - _TriangleBottom[2].z) / (_TriangleTop[2].z - _TriangleBottom[2].z)
	};

	// Build a single unique case number
	int	Case0 = s[0] < 0.0 ? 0 : (s[0] > 1.0 ? 2 : 1);
	int	Case1 = s[1] < 0.0 ? 0 : (s[1] > 1.0 ? 2 : 1);
	int	Case2 = s[2] < 0.0 ? 0 : (s[2] > 1.0 ? 2 : 1);
	int	CaseIndex = Case0 + 3 * Case1 + 9 * Case2;

	// Handle scenarios
	PS_IN	Out[5];
			Out[0].MipLevel = _MipLevel;
			Out[1].MipLevel = _MipLevel;
			Out[2].MipLevel = _MipLevel;
			Out[3].MipLevel = _MipLevel;
			Out[4].MipLevel = _MipLevel;

	// This code was automatically generated...
	switch ( CaseIndex )
	{
	case 1:	// 100 Emits 1 triangle
		Intersect( _TriangleBottom[0], _TriangleTop[0], _UVWBottom[0], _UVWTop[0], _Z, Out[0] );
		Intersect( _TriangleBottom[1], _TriangleBottom[0], _UVWBottom[1], _UVWBottom[0], _Z, Out[1] );
		Intersect( _TriangleBottom[2], _TriangleBottom[0], _UVWBottom[2], _UVWBottom[0], _Z, Out[2] );
		_Stream.Append( Out[0] );
		_Stream.Append( Out[1] );
		_Stream.Append( Out[2] );
		break;
	case 2:	// 200 Emits 2 triangles
		Intersect( _TriangleTop[0], _TriangleTop[2], _UVWTop[0], _UVWTop[2], _Z, Out[0] );
		Intersect( _TriangleTop[0], _TriangleTop[1], _UVWTop[0], _UVWTop[1], _Z, Out[1] );
		Intersect( _TriangleBottom[1], _TriangleBottom[0], _UVWBottom[1], _UVWBottom[0], _Z, Out[2] );
		Intersect( _TriangleBottom[2], _TriangleBottom[0], _UVWBottom[2], _UVWBottom[0], _Z, Out[3] );
		_Stream.Append( Out[1] );
		_Stream.Append( Out[0] );
		_Stream.Append( Out[2] );
		_Stream.Append( Out[3] );
		break;
	case 3:	// 010 Emits 1 triangle
		Intersect( _TriangleBottom[0], _TriangleBottom[1], _UVWBottom[0], _UVWBottom[1], _Z, Out[0] );
		Intersect( _TriangleBottom[1], _TriangleTop[1], _UVWBottom[1], _UVWTop[1], _Z, Out[1] );
		Intersect( _TriangleBottom[2], _TriangleBottom[1], _UVWBottom[2], _UVWBottom[1], _Z, Out[2] );
		_Stream.Append( Out[0] );
		_Stream.Append( Out[1] );
		_Stream.Append( Out[2] );
		break;
	case 4:	// 110 Emits 2 triangles
		Intersect( _TriangleBottom[0], _TriangleTop[0], _UVWBottom[0], _UVWTop[0], _Z, Out[0] );
		Intersect( _TriangleBottom[1], _TriangleTop[1], _UVWBottom[1], _UVWTop[1], _Z, Out[1] );
		Intersect( _TriangleBottom[2], _TriangleBottom[1], _UVWBottom[2], _UVWBottom[1], _Z, Out[2] );
		Intersect( _TriangleBottom[2], _TriangleBottom[0], _UVWBottom[2], _UVWBottom[0], _Z, Out[3] );
		_Stream.Append( Out[1] );
		_Stream.Append( Out[0] );
		_Stream.Append( Out[2] );
		_Stream.Append( Out[3] );
		break;
	case 5:	// 210 Emits 3 triangles
		Intersect( _TriangleTop[0], _TriangleTop[2], _UVWTop[0], _UVWTop[2], _Z, Out[0] );
		Intersect( _TriangleTop[0], _TriangleTop[1], _UVWTop[0], _UVWTop[1], _Z, Out[1] );
		Intersect( _TriangleBottom[1], _TriangleTop[1], _UVWBottom[1], _UVWTop[1], _Z, Out[2] );
		Intersect( _TriangleBottom[2], _TriangleBottom[1], _UVWBottom[2], _UVWBottom[1], _Z, Out[3] );
		Intersect( _TriangleBottom[2], _TriangleBottom[0], _UVWBottom[2], _UVWBottom[0], _Z, Out[4] );
		_Stream.Append( Out[1] );
		_Stream.Append( Out[0] );
		_Stream.Append( Out[2] );
		_Stream.Append( Out[3] );
		_Stream.RestartStrip();
		_Stream.Append( Out[0] );
		_Stream.Append( Out[3] );
		_Stream.Append( Out[4] );
		break;
	case 6:	// 020 Emits 2 triangles
		Intersect( _TriangleBottom[0], _TriangleBottom[1], _UVWBottom[0], _UVWBottom[1], _Z, Out[0] );
		Intersect( _TriangleTop[1], _TriangleTop[0], _UVWTop[1], _UVWTop[0], _Z, Out[1] );
		Intersect( _TriangleTop[1], _TriangleTop[2], _UVWTop[1], _UVWTop[2], _Z, Out[2] );
		Intersect( _TriangleBottom[2], _TriangleBottom[1], _UVWBottom[2], _UVWBottom[1], _Z, Out[3] );
		_Stream.Append( Out[1] );
		_Stream.Append( Out[0] );
		_Stream.Append( Out[2] );
		_Stream.Append( Out[3] );
		break;
	case 7:	// 120 Emits 3 triangles
		Intersect( _TriangleBottom[0], _TriangleTop[0], _UVWBottom[0], _UVWTop[0], _Z, Out[0] );
		Intersect( _TriangleTop[1], _TriangleTop[0], _UVWTop[1], _UVWTop[0], _Z, Out[1] );
		Intersect( _TriangleTop[1], _TriangleTop[2], _UVWTop[1], _UVWTop[2], _Z, Out[2] );
		Intersect( _TriangleBottom[2], _TriangleBottom[1], _UVWBottom[2], _UVWBottom[1], _Z, Out[3] );
		Intersect( _TriangleBottom[2], _TriangleBottom[0], _UVWBottom[2], _UVWBottom[0], _Z, Out[4] );
		_Stream.Append( Out[1] );
		_Stream.Append( Out[0] );
		_Stream.Append( Out[2] );
		_Stream.Append( Out[3] );
		_Stream.RestartStrip();
		_Stream.Append( Out[0] );
		_Stream.Append( Out[3] );
		_Stream.Append( Out[4] );
		break;
	case 8:	// 220 Emits 2 triangles
		Intersect( _TriangleTop[0], _TriangleTop[2], _UVWTop[0], _UVWTop[2], _Z, Out[0] );
		Intersect( _TriangleTop[1], _TriangleTop[2], _UVWTop[1], _UVWTop[2], _Z, Out[1] );
		Intersect( _TriangleBottom[2], _TriangleBottom[1], _UVWBottom[2], _UVWBottom[1], _Z, Out[2] );
		Intersect( _TriangleBottom[2], _TriangleBottom[0], _UVWBottom[2], _UVWBottom[0], _Z, Out[3] );
		_Stream.Append( Out[1] );
		_Stream.Append( Out[0] );
		_Stream.Append( Out[2] );
		_Stream.Append( Out[3] );
		break;
	case 9:	// 001 Emits 1 triangle
		Intersect( _TriangleBottom[0], _TriangleBottom[2], _UVWBottom[0], _UVWBottom[2], _Z, Out[0] );
		Intersect( _TriangleBottom[1], _TriangleBottom[2], _UVWBottom[1], _UVWBottom[2], _Z, Out[1] );
		Intersect( _TriangleBottom[2], _TriangleTop[2], _UVWBottom[2], _UVWTop[2], _Z, Out[2] );
		_Stream.Append( Out[0] );
		_Stream.Append( Out[1] );
		_Stream.Append( Out[2] );
		break;
	case 10:	// 101 Emits 2 triangles
		Intersect( _TriangleBottom[0], _TriangleTop[0], _UVWBottom[0], _UVWTop[0], _Z, Out[0] );
		Intersect( _TriangleBottom[1], _TriangleBottom[0], _UVWBottom[1], _UVWBottom[0], _Z, Out[1] );
		Intersect( _TriangleBottom[1], _TriangleBottom[2], _UVWBottom[1], _UVWBottom[2], _Z, Out[2] );
		Intersect( _TriangleBottom[2], _TriangleTop[2], _UVWBottom[2], _UVWTop[2], _Z, Out[3] );
		_Stream.Append( Out[1] );
		_Stream.Append( Out[0] );
		_Stream.Append( Out[2] );
		_Stream.Append( Out[3] );
		break;
	case 11:	// 201 Emits 3 triangles
		Intersect( _TriangleTop[0], _TriangleTop[2], _UVWTop[0], _UVWTop[2], _Z, Out[0] );
		Intersect( _TriangleTop[0], _TriangleTop[1], _UVWTop[0], _UVWTop[1], _Z, Out[1] );
		Intersect( _TriangleBottom[1], _TriangleBottom[0], _UVWBottom[1], _UVWBottom[0], _Z, Out[2] );
		Intersect( _TriangleBottom[1], _TriangleBottom[2], _UVWBottom[1], _UVWBottom[2], _Z, Out[3] );
		Intersect( _TriangleBottom[2], _TriangleTop[2], _UVWBottom[2], _UVWTop[2], _Z, Out[4] );
		_Stream.Append( Out[1] );
		_Stream.Append( Out[0] );
		_Stream.Append( Out[2] );
		_Stream.Append( Out[3] );
		_Stream.RestartStrip();
		_Stream.Append( Out[0] );
		_Stream.Append( Out[3] );
		_Stream.Append( Out[4] );
		break;
	case 12:	// 011 Emits 2 triangles
		Intersect( _TriangleBottom[0], _TriangleBottom[2], _UVWBottom[0], _UVWBottom[2], _Z, Out[0] );
		Intersect( _TriangleBottom[0], _TriangleBottom[1], _UVWBottom[0], _UVWBottom[1], _Z, Out[1] );
		Intersect( _TriangleBottom[1], _TriangleTop[1], _UVWBottom[1], _UVWTop[1], _Z, Out[2] );
		Intersect( _TriangleBottom[2], _TriangleTop[2], _UVWBottom[2], _UVWTop[2], _Z, Out[3] );
		_Stream.Append( Out[1] );
		_Stream.Append( Out[0] );
		_Stream.Append( Out[2] );
		_Stream.Append( Out[3] );
		break;
	case 13:	// 111 Emits 1 triangle
		Intersect( _TriangleBottom[0], _TriangleTop[0], _UVWBottom[0], _UVWTop[0], _Z, Out[0] );
		Intersect( _TriangleBottom[1], _TriangleTop[1], _UVWBottom[1], _UVWTop[1], _Z, Out[1] );
		Intersect( _TriangleBottom[2], _TriangleTop[2], _UVWBottom[2], _UVWTop[2], _Z, Out[2] );
		_Stream.Append( Out[0] );
		_Stream.Append( Out[1] );
		_Stream.Append( Out[2] );
		break;
	case 14:	// 211 Emits 2 triangles
		Intersect( _TriangleTop[0], _TriangleTop[2], _UVWTop[0], _UVWTop[2], _Z, Out[0] );
		Intersect( _TriangleTop[0], _TriangleTop[1], _UVWTop[0], _UVWTop[1], _Z, Out[1] );
		Intersect( _TriangleBottom[1], _TriangleTop[1], _UVWBottom[1], _UVWTop[1], _Z, Out[2] );
		Intersect( _TriangleBottom[2], _TriangleTop[2], _UVWBottom[2], _UVWTop[2], _Z, Out[3] );
		_Stream.Append( Out[1] );
		_Stream.Append( Out[0] );
		_Stream.Append( Out[2] );
		_Stream.Append( Out[3] );
		break;
	case 15:	// 021 Emits 3 triangles
		Intersect( _TriangleBottom[0], _TriangleBottom[2], _UVWBottom[0], _UVWBottom[2], _Z, Out[0] );
		Intersect( _TriangleBottom[0], _TriangleBottom[1], _UVWBottom[0], _UVWBottom[1], _Z, Out[1] );
		Intersect( _TriangleTop[1], _TriangleTop[0], _UVWTop[1], _UVWTop[0], _Z, Out[2] );
		Intersect( _TriangleTop[1], _TriangleTop[2], _UVWTop[1], _UVWTop[2], _Z, Out[3] );
		Intersect( _TriangleBottom[2], _TriangleTop[2], _UVWBottom[2], _UVWTop[2], _Z, Out[4] );
		_Stream.Append( Out[1] );
		_Stream.Append( Out[0] );
		_Stream.Append( Out[2] );
		_Stream.Append( Out[3] );
		_Stream.RestartStrip();
		_Stream.Append( Out[0] );
		_Stream.Append( Out[3] );
		_Stream.Append( Out[4] );
		break;
	case 16:	// 121 Emits 2 triangles
		Intersect( _TriangleBottom[0], _TriangleTop[0], _UVWBottom[0], _UVWTop[0], _Z, Out[0] );
		Intersect( _TriangleTop[1], _TriangleTop[0], _UVWTop[1], _UVWTop[0], _Z, Out[1] );
		Intersect( _TriangleTop[1], _TriangleTop[2], _UVWTop[1], _UVWTop[2], _Z, Out[2] );
		Intersect( _TriangleBottom[2], _TriangleTop[2], _UVWBottom[2], _UVWTop[2], _Z, Out[3] );
		_Stream.Append( Out[1] );
		_Stream.Append( Out[0] );
		_Stream.Append( Out[2] );
		_Stream.Append( Out[3] );
		break;
	case 17:	// 221 Emits 1 triangle
		Intersect( _TriangleTop[0], _TriangleTop[2], _UVWTop[0], _UVWTop[2], _Z, Out[0] );
		Intersect( _TriangleTop[1], _TriangleTop[2], _UVWTop[1], _UVWTop[2], _Z, Out[1] );
		Intersect( _TriangleBottom[2], _TriangleTop[2], _UVWBottom[2], _UVWTop[2], _Z, Out[2] );
		_Stream.Append( Out[0] );
		_Stream.Append( Out[1] );
		_Stream.Append( Out[2] );
		break;
	case 18:	// 002 Emits 2 triangles
		Intersect( _TriangleBottom[0], _TriangleBottom[2], _UVWBottom[0], _UVWBottom[2], _Z, Out[0] );
		Intersect( _TriangleBottom[1], _TriangleBottom[2], _UVWBottom[1], _UVWBottom[2], _Z, Out[1] );
		Intersect( _TriangleTop[2], _TriangleTop[1], _UVWTop[2], _UVWTop[1], _Z, Out[2] );
		Intersect( _TriangleTop[2], _TriangleTop[0], _UVWTop[2], _UVWTop[0], _Z, Out[3] );
		_Stream.Append( Out[1] );
		_Stream.Append( Out[0] );
		_Stream.Append( Out[2] );
		_Stream.Append( Out[3] );
		break;
	case 19:	// 102 Emits 3 triangles
		Intersect( _TriangleBottom[0], _TriangleTop[0], _UVWBottom[0], _UVWTop[0], _Z, Out[0] );
		Intersect( _TriangleBottom[1], _TriangleBottom[0], _UVWBottom[1], _UVWBottom[0], _Z, Out[1] );
		Intersect( _TriangleBottom[1], _TriangleBottom[2], _UVWBottom[1], _UVWBottom[2], _Z, Out[2] );
		Intersect( _TriangleTop[2], _TriangleTop[1], _UVWTop[2], _UVWTop[1], _Z, Out[3] );
		Intersect( _TriangleTop[2], _TriangleTop[0], _UVWTop[2], _UVWTop[0], _Z, Out[4] );
		_Stream.Append( Out[1] );
		_Stream.Append( Out[0] );
		_Stream.Append( Out[2] );
		_Stream.Append( Out[3] );
		_Stream.RestartStrip();
		_Stream.Append( Out[0] );
		_Stream.Append( Out[3] );
		_Stream.Append( Out[4] );
		break;
	case 20:	// 202 Emits 2 triangles
		Intersect( _TriangleTop[0], _TriangleTop[1], _UVWTop[0], _UVWTop[1], _Z, Out[0] );
		Intersect( _TriangleBottom[1], _TriangleBottom[0], _UVWBottom[1], _UVWBottom[0], _Z, Out[1] );
		Intersect( _TriangleBottom[1], _TriangleBottom[2], _UVWBottom[1], _UVWBottom[2], _Z, Out[2] );
		Intersect( _TriangleTop[2], _TriangleTop[1], _UVWTop[2], _UVWTop[1], _Z, Out[3] );
		_Stream.Append( Out[1] );
		_Stream.Append( Out[0] );
		_Stream.Append( Out[2] );
		_Stream.Append( Out[3] );
		break;
	case 21:	// 012 Emits 3 triangles
		Intersect( _TriangleBottom[0], _TriangleBottom[2], _UVWBottom[0], _UVWBottom[2], _Z, Out[0] );
		Intersect( _TriangleBottom[0], _TriangleBottom[1], _UVWBottom[0], _UVWBottom[1], _Z, Out[1] );
		Intersect( _TriangleBottom[1], _TriangleTop[1], _UVWBottom[1], _UVWTop[1], _Z, Out[2] );
		Intersect( _TriangleTop[2], _TriangleTop[1], _UVWTop[2], _UVWTop[1], _Z, Out[3] );
		Intersect( _TriangleTop[2], _TriangleTop[0], _UVWTop[2], _UVWTop[0], _Z, Out[4] );
		_Stream.Append( Out[1] );
		_Stream.Append( Out[0] );
		_Stream.Append( Out[2] );
		_Stream.Append( Out[3] );
		_Stream.RestartStrip();
		_Stream.Append( Out[0] );
		_Stream.Append( Out[3] );
		_Stream.Append( Out[4] );
		break;
	case 22:	// 112 Emits 2 triangles
		Intersect( _TriangleBottom[0], _TriangleTop[0], _UVWBottom[0], _UVWTop[0], _Z, Out[0] );
		Intersect( _TriangleBottom[1], _TriangleTop[1], _UVWBottom[1], _UVWTop[1], _Z, Out[1] );
		Intersect( _TriangleTop[2], _TriangleTop[1], _UVWTop[2], _UVWTop[1], _Z, Out[2] );
		Intersect( _TriangleTop[2], _TriangleTop[0], _UVWTop[2], _UVWTop[0], _Z, Out[3] );
		_Stream.Append( Out[1] );
		_Stream.Append( Out[0] );
		_Stream.Append( Out[2] );
		_Stream.Append( Out[3] );
		break;
	case 23:	// 212 Emits 1 triangle
		Intersect( _TriangleTop[0], _TriangleTop[1], _UVWTop[0], _UVWTop[1], _Z, Out[0] );
		Intersect( _TriangleBottom[1], _TriangleTop[1], _UVWBottom[1], _UVWTop[1], _Z, Out[1] );
		Intersect( _TriangleTop[2], _TriangleTop[1], _UVWTop[2], _UVWTop[1], _Z, Out[2] );
		_Stream.Append( Out[0] );
		_Stream.Append( Out[1] );
		_Stream.Append( Out[2] );
		break;
	case 24:	// 022 Emits 2 triangles
		Intersect( _TriangleBottom[0], _TriangleBottom[2], _UVWBottom[0], _UVWBottom[2], _Z, Out[0] );
		Intersect( _TriangleBottom[0], _TriangleBottom[1], _UVWBottom[0], _UVWBottom[1], _Z, Out[1] );
		Intersect( _TriangleTop[1], _TriangleTop[0], _UVWTop[1], _UVWTop[0], _Z, Out[2] );
		Intersect( _TriangleTop[2], _TriangleTop[0], _UVWTop[2], _UVWTop[0], _Z, Out[3] );
		_Stream.Append( Out[1] );
		_Stream.Append( Out[0] );
		_Stream.Append( Out[2] );
		_Stream.Append( Out[3] );
		break;
	case 25:	// 122 Emits 1 triangle
		Intersect( _TriangleBottom[0], _TriangleTop[0], _UVWBottom[0], _UVWTop[0], _Z, Out[0] );
		Intersect( _TriangleTop[1], _TriangleTop[0], _UVWTop[1], _UVWTop[0], _Z, Out[1] );
		Intersect( _TriangleTop[2], _TriangleTop[0], _UVWTop[2], _UVWTop[0], _Z, Out[2] );
		_Stream.Append( Out[0] );
		_Stream.Append( Out[1] );
		_Stream.Append( Out[2] );
		break;
	}
}

[maxvertexcount( 2*7 )]
void	GS( point VS_IN _In[1], inout TriangleStream<PS_IN> _Stream )
{
	// First prism
	float4	Bottom0[] = { BBox[7], BBox[3], BBox[2] };
	float4	Top0[] = { BBox[4], BBox[0], BBox[1] };
	float3	UVWB0[] = { BBoxUVW[7], BBoxUVW[3], BBoxUVW[2] };
	float3	UVWT0[] = { BBoxUVW[4], BBoxUVW[0], BBoxUVW[1] };
	CutPrism( Bottom0, Top0, UVWB0, UVWT0, _In[0].DepthMip.x, _In[0].DepthMip.y, _Stream );
 
 	// Second prism
	float4	Bottom1[] = { BBox[7], BBox[2], BBox[6] };
	float4	Top1[] = { BBox[4], BBox[1], BBox[5] };
	float3	UVWB1[] = { BBoxUVW[7], BBoxUVW[2], BBoxUVW[6] };
	float3	UVWT1[] = { BBoxUVW[4], BBoxUVW[1], BBoxUVW[5] };
	CutPrism( Bottom1, Top1, UVWB1, UVWT1, _In[0].DepthMip.x, _In[0].DepthMip.y, _Stream );
}

// Render
float4 PS( PS_IN _In ) : SV_TARGET0
{
	float3	UVW = _In.UVW + float3( 0.0, 0.0, 0.5 * VolumeInvSize.z );	// Little bias on Z
//return float4( UVW, 1 );

//_In.MipLevel = 0.0;

	float4	Diffuse = DiffuseAlpha.SampleLevel( LinearClamp, UVW, _In.MipLevel );
	clip( Diffuse.w - 1e-3 );
	float3	N = Normal.SampleLevel( LinearClamp, UVW, _In.MipLevel ).xyz;

	if ( PreMultiplyByAlpha )
	{
		Diffuse.xyz /= Diffuse.w;	// Un-premultiply by alpha
		N /= Diffuse.w;				// Normal too !
	}
//	return Diffuse;
//	return float4( N, 1.0 );

//	return float4( _In.MipLevel.xxx, 1.0 );

//N = normalize( float3( 0, 1, 1 ) );

	float	DotDiffuse = saturate( 0.3 + 0.7 * dot( N, ToLight ) );
	return float4( Diffuse.xyz * (0.05 + DotDiffuse), Diffuse.w );
}

// ===================================================================================
// This GS expands the point into 4 vertices (i.e. a single strip) that encompass the bounding box
[maxvertexcount( 4 )]
void	GS2( point VS_IN _In[1], inout TriangleStream<PS_IN> _Stream )
{
	PS_IN	Out;
	Out.MipLevel = _In[0].DepthMip.y;
//Out.MipLevel = 2.0 + _In[0].DepthMip.y;	// Bias
	float2	Z = float2( _In[0].DepthMip.x, 1.0 );

	// Top Left corner
	float4	Position = float4( BBoxMinMax.x, BBoxMinMax.w, Z );
	Out.Position = mul( Position, Camera2Proj );
	Out.UVW = mul( Position, Camera2BBoxUVW ).xyz;
	_Stream.Append( Out );

	// Bottom Left corner
	Position = float4( BBoxMinMax.x, BBoxMinMax.y, Z );
	Out.Position = mul( Position, Camera2Proj );
	Out.UVW = mul( Position, Camera2BBoxUVW ).xyz;
	_Stream.Append( Out );

	// Top Right corner
	Position = float4( BBoxMinMax.z, BBoxMinMax.w, Z );
	Out.Position = mul( Position, Camera2Proj );
	Out.UVW = mul( Position, Camera2BBoxUVW ).xyz;
	_Stream.Append( Out );

	// Bottom Right corner
	Position = float4( BBoxMinMax.z, BBoxMinMax.y, Z );
	Out.Position = mul( Position, Camera2Proj );
	Out.UVW = mul( Position, Camera2BBoxUVW ).xyz;
	_Stream.Append( Out );
}

// Render
float4 PS2( PS_IN _In ) : SV_TARGET0
{
	float3	UVW = _In.UVW + float3( 0.0, 0.0, 0.5 * VolumeInvSize.z );	// Little bias on Z
	clip( UVW.x );
	clip( UVW.y );
	clip( UVW.z );
	clip( 1.0 - UVW.x );
	clip( 1.0 - UVW.y );
	clip( 1.0 - UVW.z );
//return float4( UVW, 1 );

	float4	Diffuse = DiffuseAlpha.SampleLevel( LinearClamp, UVW, _In.MipLevel );
	clip( Diffuse.w - 1e-3 );
	float3	N = Normal.SampleLevel( LinearClamp, UVW, _In.MipLevel ).xyz;

	if ( PreMultiplyByAlpha )
	{
		Diffuse.xyz /= Diffuse.w;	// Un-premultiply by alpha
		N /= Diffuse.w;				// Normal too !
	}
//	return Diffuse;
//	return float4( N, 1.0 );

//	return float4( _In.MipLevel.xxx, 1.0 );

//N = normalize( float3( 0, 1, 1 ) );

	float	DotDiffuse = saturate( 0.3 + 0.7 * dot( N, ToLight ) );
	return float4( Diffuse.xyz * (0.05 + DotDiffuse), Diffuse.w );
}

// ===================================================================================
//
technique10 RenderVolumeMesh
{
	pass P0
	{
		SetVertexShader( CompileShader( vs_4_0, VS() ) );
		SetGeometryShader( CompileShader( gs_4_0, GS() ) );
		SetPixelShader( CompileShader( ps_4_0, PS() ) );
	}
}

technique10 RenderVolumeMesh_NoSlicing
{
	pass P0
	{
		SetVertexShader( CompileShader( vs_4_0, VS() ) );
		SetGeometryShader( CompileShader( gs_4_0, GS2() ) );
		SetPixelShader( CompileShader( ps_4_0, PS2() ) );
	}
}
