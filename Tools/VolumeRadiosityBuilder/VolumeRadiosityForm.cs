//////////////////////////////////////////////////////////////////////////
//
// This application builds the necessary textures and structures to perform "realtime" radiosity.
//
// The idea behind volume radiosity is to re-use my volume mesh builder to render a
//	scene into a 3D texture and use that 3D texture as a base for radiosity rendering.
//
// The different stages in this application are :
//	1) Generate a map (Map #1) of continous, non empty voxels using the histo-pyramids algorithm (http://folk.uio.no/erikd/histo/hpmarchertalk.pdf)
//		=> That results in a single 2D texture containing the voxel position of the V non-empty voxels
//		=> Accessing this map gives the position where to sample the albedo and normal generated by the VolumeMeshBuilder application
//
//	2) Generate the inverse map (Map #1'), a 3D map where each non empty voxel points to the the pixels in Map #1
//
//	3) Generate a map (Map #2) of form factors for each point of Map #1
//		=> We do that by casting N rays from each point in Map #1 in close to normal direction and storing the index of the hit point
//		=> That results in N * V pixels that will be compacted into several maps
//			-> There are several schemes that can be used to pack the results :
//				-> If the total amount of non empty voxels V is < 65535 then we can simply store the index of the non-empty voxel in 2 bytes
//					thus efficiently packing 2 rays into a single RGBA8 render target (up to 16 rays for 8 render targets)
//				   In that case, the actual albedo and normal of the hit point needs to be accessed via an indirection through Map #1
//				-> Otherwise, if V >= 65535 then we simply store the voxel position (XYZ, each a byte) in a RGBA8 target thus
//					packing 10 rays in 8 RGBA render targets (10*3=30 slots used amongs the 32 available)
//				   In that case, the actual albedo and normal of the hit point is directly accessible since we have the position of the hit voxel.
//		=> Accessing this map gives the positions of the N hits off the origin whose position is given by Map #1
//
//	4) (optional) Generate a map (Map #3) which represents the scene's distance field in the 6 principal directions for runtime sampling
//		of the radiance field.
//
// =========================================================================
// Then, once these maps are built, the algorithm to use them goes like this :
//
//	1] Perform irradiance computation of the list of points in Map #1
//		=> This gives us the initial direct lighting component
//		=> Note that you can use any renderer to perform this, ones that include shadow mapping, sky lighting and such
//
//	2] Rendering a 3D map slice by slice, for each non empty voxel use Map #1' to sample the irradiance computed by step 1]
//		=> Build mip levels for that 3D irradiance map
//
//	3] Perform gathering of irradiance from N neighbors into another 3D map, also slice by slice
//		=> Use Map #2 to gather irradiance for all points from map computed at step 2]
//		=> By using the distance between points in Map #1 and Map #2 and the amount of sampling points N,
//			we can deduce the radius of a sampling sphere, hence the mip level to sample from (i.e. irradiance, albedo and normal)
//
//	4] Repeat step 3] B times, B being the amount of bounces to consider
//		=> At the end, accumulate all results except direct lighting.
//		=> This yields the indirect lighting for the scene
//
//	5] [DISPLAY] For each mesh (per pixel or per vertex) at position P and normal N
//		5.1] Sample the distance field at P, this gives us the position of the closest wall
//			(Note: When using the optional Map #3, we can sample 3 distance fields among the 6 available depending on the signs
//			of the XYZ components of the normal N, this will give us 3 directions to the 3 closest positions, each in the
//			direction of interest. Therefore we simply have to perform a summed average of 3 indirect lighting values)
//
//		5.2] Sample irradiance at wall position from the indirect irradiance map computed by steps 3] and 4]
//			=> Here you go !
//
//////////////////////////////////////////////////////////////////////////

//#define DEBUG_SLICES

#define UPDATE_RADIOSITY_EVERY_FRAME

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Windows.Forms;

using SharpDX;
using SharpDX.Direct3D10;
using SharpDX.DXGI;

using Nuaj;
using Nuaj.Cirrus;
using Nuaj.Cirrus.FBX;

namespace VolumeRadiosityBuilder
{
	public partial class VolumeRadiosityForm : Form, IShaderInterfaceProvider
	{
		#region CONSTANTS

		// Radiosity volume data
		protected const int		RAY_BUNDLES_COUNT = 5;					// Each bundle corresponds to 10 gathering rays
		protected const double	GATHERING_MAX_THETA = 90.0;				// The maximum covered angle (in degrees) for the gathering hemisphere
		protected const float	OFFSET_OFF_WALLS = 0.1f;				// The distance off the walls for gathering rays (this avoids ray-tracing acnea)

		// Realtime radiosity update data
		protected const float	RADIOSITY_UPDATE_MILLISECONDS = 1.0f;	// No more than 1ms spent in radiosity update each frame !

		protected static readonly Vector3	ENVIRONMENT_COLOR = new Vector3( 0.3f, 0.8f, 1.0f );
		protected static readonly Vector3	LIGHT_COLOR = Vector3.One;

		#endregion

		#region NESTED TYPES

		protected class	IVolumeRadiosity : ShaderInterfaceBase
		{
			[Semantic( "VR_FIELD_ORIGIN" )]
			public Vector3		FieldOrigin				{ set { SetVector( "VR_FIELD_ORIGIN", value ); } }
			[Semantic( "VR_VOXEL_SIZE" )]
			public float		VoxelSize				{ set { SetScalar( "VR_VOXEL_SIZE", value ); } }
			[Semantic( "VR_VOXEL_INV_SIZE" )]
			public float		VoxelInvSize			{ set { SetScalar( "VR_VOXEL_INV_SIZE", value ); } }
			[Semantic( "VR_MIP_BIAS" )]
			public float		MipBias					{ set { SetScalar( "VR_MIP_BIAS", value ); } }
			[Semantic( "VR_VOLUME_INV_SIZE" )]
			public Vector3		VolumeInvSize			{ set { SetVector( "VR_VOLUME_INV_SIZE", value ); } }
			[Semantic( "VR_INDIRECT_LIGHTING_FIELD" )]
			public ITexture3D	IndirectLightingField	{ set { SetResource( "VR_INDIRECT_LIGHTING_FIELD", value ); } }
			[Semantic( "VR_DISTANCE_FIELD" )]
			public ITexture3D	DistanceField			{ set { SetResource( "VR_DISTANCE_FIELD", value ); } }
			[Semantic( "VR_DIFFUSE_FIELD" )]
			public ITexture3D	DiffuseField			{ set { SetResource( "VR_DIFFUSE_FIELD", value ); } }
		}

		#endregion

		#region FIELDS

		protected Nuaj.Device					m_Device = null;

		//////////////////////////////////////////////////////////////////////////
		// Scene and renderer
		protected SceneTextureProvider			m_TextureProvider = null;
		protected Scene							m_Scene = null;

		protected Renderer						m_Renderer = null;
		protected RenderTechniqueSceneShadowMap	m_RenderShadowMap = null;
		protected RenderTechniqueScene			m_RenderScene = null;

		protected Camera 						m_Camera = null;
		protected Nuaj.Helpers.CameraManipulator	m_CamManipulator = null;

		//////////////////////////////////////////////////////////////////////////
		// Materials
		Material<VS_Pt4>						m_MaterialDebugVolume = null;

		//////////////////////////////////////////////////////////////////////////
		// Textures
		protected RenderTarget3D<PF_RGBA16F>	m_DiffuseAlpha = null;
		protected RenderTarget3D<PF_RGBA16F>	m_Normal = null;
		protected RenderTarget3D<PF_RGBA16F>	m_DistanceField = null;


		protected Texture2D<PF_RGBA8>			m_PrecisionTest = null;

		//////////////////////////////////////////////////////////////////////////
		// Primitives
		Nuaj.Helpers.ScreenQuad					m_Quad = null;

		protected Nuaj.Cirrus.Utility.ProfilerForm	m_Profiler = null;
		protected bool							m_bDrawInfos = false;

		// Dispose stack
		protected Stack<IDisposable>			m_Disposables = new Stack<IDisposable>();

		#endregion

		#region METHODS

		public VolumeRadiosityForm()
		{
			InitializeComponent();

			//////////////////////////////////////////////////////////////////////////
			// Create the device
			try
			{
				SwapChainDescription	Desc = new SwapChainDescription()
				{
					BufferCount = 1,
					ModeDescription = new ModeDescription( panelOutput.Width, panelOutput.Height, new Rational(60, 1), Format.R8G8B8A8_UNorm ),
					IsWindowed = true,
					SampleDescription = new SampleDescription( 1, 0 ),
					SwapEffect = SwapEffect.Discard,
					Usage = Usage.RenderTargetOutput
				};

				m_Device = ToDispose( Nuaj.Device.CreateInstance( Desc, panelOutput, false ) );
			}
			catch ( Exception _e )
			{
				throw new Exception( "Failed to create the DirectX device !", _e );
			}

			//////////////////////////////////////////////////////////////////////////
			// Declare the IVolumeRadiosity shader interface
			m_Device.DeclareShaderInterface( typeof(IVolumeRadiosity) );
			m_Device.RegisterShaderInterfaceProvider( typeof(IVolumeRadiosity), this );


			//////////////////////////////////////////////////////////////////////////
			// Build the main camera
			m_Camera = ToDispose( new Camera( m_Device, "Main Camera" ) );
			m_Camera.CreatePerspectiveCamera( 90.0f * (float) Math.PI / 180.0f, (float) Width / Height, 0.01f, 1000.0f );
			m_Camera.Activate();

			m_CamManipulator = new Nuaj.Helpers.CameraManipulator();
			m_CamManipulator.Attach( panelOutput, m_Camera );
			m_CamManipulator.InitializeCamera( new Vector3( 14.5f, 8.0f, 2.18f ), new Vector3( 0.0f, 2.0f, 0.0f ), Vector3.UnitY );

			m_Quad = ToDispose( new Nuaj.Helpers.ScreenQuad( m_Device, "Quad" ) );


			//////////////////////////////////////////////////////////////////////////
			// Build the debug material
			m_MaterialDebugVolume = ToDispose( new Material<VS_Pt4>( m_Device, "DebugVolume", ShaderModel.SM4_0, new System.IO.FileInfo( "./FX/VOlumeRadiosityBuilder/DebugVolume.fx" ) ) );


// DEBUG
m_PrecisionTest = ToDispose( Texture2D<PF_RGBA8>.CreateFromBitmapFile( m_Device, "PrecisionTest", new System.IO.FileInfo( "./Media/PrecisionTest128x128.png" ), 0 ) );


			//////////////////////////////////////////////////////////////////////////
			// Read back 3D textures previously computed by the VolumeMeshBuilder utility
			System.IO.FileInfo	File = new System.IO.FileInfo( "./Media/3DTextures/Sponza/Sponza_Diffuse.tex3" );
			using ( System.IO.Stream S = File.OpenRead() )
				m_DiffuseAlpha = ToDispose( RenderTarget3D<PF_RGBA16F>.CreateFromStream( m_Device, "Diffuse+Alpha", S ) );

			File = new System.IO.FileInfo( "./Media/3DTextures/Sponza/Sponza_Normal.tex3" );
			using ( System.IO.Stream S = File.OpenRead() )
				m_Normal = ToDispose( RenderTarget3D<PF_RGBA16F>.CreateFromStream( m_Device, "Normal", S ) );

			File = new System.IO.FileInfo( "./Media/3DTextures/Sponza/Sponza_Distance.tex3" );
			using ( System.IO.Stream S = File.OpenRead() )
				m_DistanceField = ToDispose( RenderTarget3D<PF_RGBA16F>.CreateFromStream( m_Device, "DistanceField", S ) );

			// We need to setup the voxel size ourselves here...
			int			VolumeWidth, VolumeHeight, VolumeDepth;
			float		VoxelSize;
			BoundingBox	SceneBBox;
			bool		bPreMultipliedAlpha;

			File = new System.IO.FileInfo( "./Media/3DTextures/Sponza/Sponza_TexParams.infos" );
			using ( System.IO.Stream S = File.OpenRead() )
				ReadTexParams( S, out VolumeWidth, out VolumeHeight, out VolumeDepth, out VoxelSize, out SceneBBox, out bPreMultipliedAlpha );

			if ( bPreMultipliedAlpha )
				throw new Exception( "We need a non-premultiplied alpha rendering for this technique !" );


			// The volume origin is the top-left-back corner
			Vector3	VolumeOrigin = new Vector3( SceneBBox.Minimum.X, SceneBBox.Maximum.Y, SceneBBox.Minimum.Z );


			//////////////////////////////////////////////////////////////////////////
			// Create the renderer & its pipelines
			m_Renderer = ToDispose( new Renderer( m_Device, "Renderer" ) );

			Pipeline	Main = ToDispose( new Pipeline( m_Device, "MainPipeline", Pipeline.TYPE.MAIN_RENDERING ) );
			m_Renderer.AddPipeline( Main );


			// Add the shadow map technique
			m_RenderShadowMap = ToDispose( new RenderTechniqueSceneShadowMap( m_Device, "Scene Shadow Map" ) );
			Main.AddTechnique( m_RenderShadowMap );

			// Add the Scene Renderer
			m_RenderScene = ToDispose( new RenderTechniqueScene( m_Device, "Scene Renderer" ) );
			m_RenderScene.Scene = m_Scene;
			m_RenderShadowMap.SceneRenderer = m_RenderScene;

			Main.AddTechnique( m_RenderScene );


#if !DEBUG_SLICES
			//////////////////////////////////////////////////////////////////////////
			// Load the FBX scene
			m_Scene = ToDispose( new Scene( m_Device, "Scene", m_Renderer ) );

			// Sponza
			string	TexturesDirectory = "./Meshes/Sponza/";
			string	SceneDirectory = "./Meshes/Sponza/";
			string	SceneName = "Sponza_RedCeiling.fbx";

			m_TextureProvider = ToDispose( new SceneTextureProvider( m_Device, "", new System.IO.DirectoryInfo( TexturesDirectory ) ) );
			m_TextureProvider.ForceCreateMipMaps = true;

			MaterialMap	MMap = new MaterialMap();
			MMap.RegisterMapper( ( Scene.MaterialParameters _MaterialParameters ) =>
			{
				return m_RenderScene;
			} );

			using ( SceneLoader SceneLoader = new SceneLoader( m_Device, "SceneLoader" ) )
			{
				SceneLoader.Load( new System.IO.FileInfo( SceneDirectory + SceneName ), m_Scene, MMap, m_TextureProvider );
			}
#endif

			//////////////////////////////////////////////////////////////////////////
			// Compute volume radiosity necessary structures
			Texture2D<PF_RGBA8>	NonEmptyVoxels2D;
			Texture3D<PF_RG16>	NonEmptyVoxels3D;
			Texture2D<PF_RGBA8>	FormFactors;
			float[]				RayWeights;

			double	MaxTheta = GATHERING_MAX_THETA * Math.PI / 180.0;

			ComputeVolumeRadiosity( 512, RAY_BUNDLES_COUNT, MaxTheta, OFFSET_OFF_WALLS, m_DiffuseAlpha, m_Normal, m_DistanceField, out NonEmptyVoxels2D, out NonEmptyVoxels3D, out FormFactors, out RayWeights );

			ToDispose( NonEmptyVoxels2D );
			ToDispose( NonEmptyVoxels3D );
			ToDispose( FormFactors );

			//////////////////////////////////////////////////////////////////////////
			// Initialze radiosity computer
			InitRadiosity( VolumeOrigin, VoxelSize, RAY_BUNDLES_COUNT, MaxTheta, RayWeights, NonEmptyVoxels2D, NonEmptyVoxels3D, FormFactors );

			// Solve radiosity once
#if !UPDATE_RADIOSITY_EVERY_FRAME

			// Setup light
			m_RenderShadowMap.LightDirection = m_RenderScene.LightDirection = new Vector3( 1.0f, 2.0f, 1.0f );
			m_RenderScene.LightColor = 20.0f * LIGHT_COLOR;

			TimeSpan	ComputationTime = UpdateRadiosity( 3, 0.1f * ENVIRONMENT_COLOR );
			MessageBox.Show( this, "Computation time for 3 bounces : " + ComputationTime.TotalSeconds + " seconds", "Infos", MessageBoxButtons.OK, MessageBoxIcon.Information );
#endif

			//////////////////////////////////////////////////////////////////////////
			// Create the profiler
			m_Profiler = new Nuaj.Cirrus.Utility.ProfilerForm( m_Device );
		}

		protected override void OnClosing( CancelEventArgs e )
		{
			while( m_Disposables.Count > 0 )
				m_Disposables.Pop().Dispose();

			base.OnClosing( e );
		}

		/// <summary>
		/// We'll keep you busy !
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="e"></param>
		public void	RunMessageLoop()
		{
			//////////////////////////////////////////////////////////////////////////
			// Start the render loop
			string		OriginalText = Text;
			DateTime	StartTime = DateTime.Now;
			DateTime	LastFrameTime = DateTime.Now;
			DateTime	LastFPSTime = DateTime.Now;
			int			FPSFramesCount = 0;
			float		fLightAngle = 0.0f;

			SharpDX.Windows.MessagePump.Run( this, () =>
			{
				// Update time
				DateTime	CurrentFrameTime = DateTime.Now;				
				float	fDeltaTime = (float) (CurrentFrameTime - LastFrameTime).TotalSeconds;
				float	fTotalTime = (float) (CurrentFrameTime - StartTime).TotalSeconds;
				LastFrameTime = CurrentFrameTime;

				if ( !m_Device.CheckCanRender( 10 ) )
				{
					Text = OriginalText + " - OCCLUDED !";
					return;
				}

				m_Device.StartProfiling( m_Profiler.FlushEveryOnTask );
				m_Device.AddProfileTask( null, "Rendering", "START" );

#if UPDATE_RADIOSITY_EVERY_FRAME

				float	Orbit = 0.5f;
				if ( checkBoxAnimateLight.Checked )
				{
					fLightAngle += 0.2f * fDeltaTime;
					fLightAngle %= 2.0f * (float) Math.PI;
				}
				else
					fLightAngle = floatTrackbarControlLightAnim.Value * 2.0f * (float) Math.PI;

				floatTrackbarControlLightAnim.Value = fLightAngle / (2.0f * (float) Math.PI);

				m_RenderScene.LightDirection = new Vector3( Orbit * (float) Math.Cos( fLightAngle ), 1.0f,  Orbit * (float) Math.Sin( fLightAngle ) );
				m_RenderShadowMap.LightDirection = m_RenderScene.LightDirection;
				m_RenderScene.LightColor = floatTrackbarControlLightIntensity.Value * LIGHT_COLOR;
				m_RenderScene.IndirectLightingBoost = floatTrackbarControlIndirectBoost.Value;
				m_RenderScene.DirectLightingBoost = checkBoxIndirectOnly.Checked ? 0.0f : 1.0f;

				m_Device.AddProfileTask( null, "Rendering", "UpdateRatiosity" );

				int			FullUpdateCallsCount = 0;
				double		FullUpdateTime = 0.0;
				TimeSpan	UpdateTime;
				if ( UpdateRadiosityTimeSliced( integerTrackbarControlBouncesCount.Value, floatTrackbarControlSkyIntensity.Value * ENVIRONMENT_COLOR, floatTrackbarControlTimeSlicing.Value, integerTrackbarControlSlicesCountPerGatheringDrawCall.Value, out UpdateTime, ref FullUpdateCallsCount, ref FullUpdateTime ) )
				{	// We have a full update !
					string	UpdateText =
						"Calls = " + FullUpdateCallsCount + "\r\n" +
						"TotalTime = " + FullUpdateTime.ToString( "G4" ) + "ms\r\n" +
						"Avg. Time = " + (FullUpdateTime / FullUpdateCallsCount).ToString( "G4" ) + "ms/call\r\n" +
						"\r\n" +
						"";
					textBoxInfos.Text = UpdateText;
				}
#endif
				// =============== Render Scene ===============
				m_Device.SetDefaultRenderTarget();
//				m_Device.ClearRenderTarget( m_Device.DefaultRenderTarget, Vector4.Zero );
				m_Device.ClearRenderTarget( m_Device.DefaultRenderTarget, new Color4( System.Drawing.Color.CornflowerBlue.ToArgb() ) );
				m_Device.ClearDepthStencil( m_Device.DefaultDepthStencil, DepthStencilClearFlags.Depth, 1.0f, 0 );

#if !DEBUG_SLICES
				m_Device.AddProfileTask( null, "Rendering", "RenderScene" );
				// Render
				m_Renderer.Render();
#else
				// Debug
				using ( m_MaterialDebugVolume.UseLock() )
				{
					m_Device.SetStockRasterizerState( Nuaj.Device.HELPER_STATES.NO_CULLING );
					m_Device.SetStockDepthStencilState( Nuaj.Device.HELPER_DEPTH_STATES.DISABLED );
//					m_Device.SetStockBlendState( Nuaj.Device.HELPER_BLEND_STATES.ADDITIVE );	// use this to debug distance field
					m_Device.SetStockBlendState( Nuaj.Device.HELPER_BLEND_STATES.BLEND );		// use this to debug diffuse/normal slices

					// Debug volume slices
					m_MaterialDebugVolume.CurrentTechnique = m_MaterialDebugVolume.GetTechniqueByName( "RenderVolumeMesh_Slices" );

					m_MaterialDebugVolume.GetVariableByName( "BufferInvSize" ).AsVector.Set( m_Device.DefaultRenderTarget.InvSize3 );

					m_MaterialDebugVolume.GetVariableByName( "DiffuseField" ).AsResource.SetResource( m_DiffuseAlpha );
					m_MaterialDebugVolume.GetVariableByName( "DistanceField" ).AsResource.SetResource( m_DistanceField );
					m_MaterialDebugVolume.GetVariableByName( "NormalField" ).AsResource.SetResource( m_Normal );

					m_MaterialDebugVolume.GetVariableByName( "WorldSize" ).AsVector.Set( 1.1f * m_VoxelSize * m_DiffuseAlpha.Size3 );
					m_MaterialDebugVolume.GetVariableByName( "VolumeSize" ).AsVector.Set( m_DiffuseAlpha.Size3 );
					m_MaterialDebugVolume.GetVariableByName( "VolumeInvSize" ).AsVector.Set( m_DiffuseAlpha.InvSize3 );

					m_MaterialDebugVolume.GetVariableByName( "MipBias" ).AsScalar.Set( floatTrackbarControlDisplayMipBias.Value );

					m_MaterialDebugVolume.GetVariableByName( "DirectIrradianceMapInvSize" ).AsVector.Set( m_MapNonEmptyVoxels0.InvSize2 );
					m_MaterialDebugVolume.GetVariableByName( "NonEmptyVoxels2Dto3D" ).AsResource.SetResource( m_MapNonEmptyVoxels0 );
					m_MaterialDebugVolume.GetVariableByName( "NonEmptyVoxels3Dto2D" ).AsResource.SetResource( m_MapNonEmptyVoxels1 );

					// The texture to debug (choose wisely !)
//					m_MaterialDebugVolume.GetVariableByName( "IndirectLightingField" ).AsResource.SetResource( m_Irradiance[0] );
					m_MaterialDebugVolume.GetVariableByName( "IndirectLightingField" ).AsResource.SetResource( m_IrradianceResult[0] );


					m_MaterialDebugVolume.ApplyPass( 0 );
					m_Quad.RenderInstanced( 0, m_DiffuseAlpha.Depth );
				}
#endif

				if ( m_bDrawInfos )
				{	// Debug infos
					using ( m_MaterialDebugVolume.UseLock() )
					{
#if true	// Embed mode
						m_Device.SetViewport( 0, 0, 256, 256, 0.0f, 1.0f );
						m_MaterialDebugVolume.GetVariableByName( "BufferInvSize" ).AsVector.Set( 1.0f / 256.0f * new Vector3( 1, 1, 0 ) );
#else		// Fullscreen mode
						m_MaterialDebugVolume.GetVariableByName( "BufferInvSize" ).AsVector.Set( m_Device.DefaultRenderTarget.InvSize3 );
#endif
						m_MaterialDebugVolume.CurrentTechnique = m_MaterialDebugVolume.GetTechniqueByName( "RenderVolumeMesh_Irradiance2D" );

						m_MaterialDebugVolume.GetVariableByName( "DirectIrradiance" ).AsResource.SetResource( m_DirectIrradiance2D );

						m_MaterialDebugVolume.GetVariableByName( "PrecisionTest" ).AsResource.SetResource( m_PrecisionTest );

						m_MaterialDebugVolume.ApplyPass( 0 );
						m_Quad.Render();
					}
				}

				// Show !
				m_Device.Present();

				m_Device.AddProfileTask( null, "Rendering", "END" );
				m_Device.EndProfiling();

				// Update FPS
				FPSFramesCount++;
				DateTime	Now = DateTime.Now;
				double		DeltaMilliseconds = (Now - LastFPSTime).TotalMilliseconds;
				if ( DeltaMilliseconds > 1000 )
				{
					float	FPS = (float) (1000.0 * FPSFramesCount / DeltaMilliseconds);
					LastFPSTime = Now;
					FPSFramesCount = 0;
					Text = OriginalText + " - " + FPS.ToString( "G4" ) + " FPS";
				}
			} );
		}

		protected T	ToDispose<T>( T _Item ) where T : IDisposable
		{
			IDisposable	I = _Item as IDisposable;
			if ( I != null )
				m_Disposables.Push( I );

			return _Item;
		}

		#region Volume Radiosity Building

		protected struct	VoxelPosition
		{
			public byte	X, Y, Z;
		}

		protected struct	MapPosition2D
		{
			public ushort X, Y;
		}

		/// <summary>
		/// Builds the structures necessary for the volume radiosity algorithm
		/// </summary>
		/// <param name="_Map2DWidth">The width of the map of non empty voxels (height is determined by the amount of non empty voxels divided by that width)</param>
		/// <param name="_RayBundlesCount">The amounf of ray bundle to use for form factors. A bundle contains 10 rays packed into 8 render targets. If you use 2 bundles, you'll need 16 render targets and so on...</param>
		/// <param name="_MaxTheta">The maximum elevation angle off the normal we generate rays for (the actual maximum is PI/2 but it's advised to choose up to PI/3 as grazing rays don't account for much in form factors computation)</param>
		/// <param name="_OffsetOffWalls">The distance to offset rays from the walls to avoid ray-tracing acnea (in VOXEL units)</param>
		/// 
		/// <param name="_DiffuseAlpha">The scene's Diffuse+Alpha 3D texture</param>
		/// <param name="_Normal">The scene's Normal 3D texture</param>
		/// <param name="_DistanceField">The scene's Distance 3D texture</param>
		/// <param name="_VoxelSize">Size of a volume element</param>
		/// <param name="_MapNonEmptyVoxels0">The 2D map containing the sequential list of non empty voxel positions</param>
		/// <param name="_MapNonEmptyVoxels1">The 3D map that contains either an invalid coordinate (empty voxel) or the 2D coordinate in 2D map described above (non empty voxel)</param>
		/// <param name="_FormFactors">A Texture2DArray map containing, for each non empty voxel, a list of ray intersections with other non-empty voxels. This is used to compute the form factors</param>
		/// <param name="_RayWeights">The list of weights (i.e. dot products) off the normal for each gathering ray</param>
		protected void	ComputeVolumeRadiosity( int _Map2DWidth, int _RayBundlesCount, double _MaxTheta, float _OffsetOffWalls, RenderTarget3D<PF_RGBA16F> _DiffuseAlpha, RenderTarget3D<PF_RGBA16F> _Normal, RenderTarget3D<PF_RGBA16F> _DistanceField, out Texture2D<PF_RGBA8> _MapNonEmptyVoxels0, out Texture3D<PF_RG16> _MapNonEmptyVoxels1, out Texture2D<PF_RGBA8> _FormFactors, out float[] _RayWeights )
		{
			//////////////////////////////////////////////////////////////////////////
			// First of all, we need to isolate the non empty voxels and build 2 maps :
			//	* A 2D map (Map #1) that contains the 3D voxel coordinates of all non empty voxels
			//	* A 3D map (Map #1') that, for each non empty voxel, contains their 2D position in map #1
			//
			Texture3DCPU<PF_RGBA16F>	ReadableDiffuseAlpha = new Texture3DCPU<PF_RGBA16F>( m_Device, "CPUDiffuse+Alpha", _DiffuseAlpha.Width, _DiffuseAlpha.Height, _DiffuseAlpha.Depth, _DiffuseAlpha.MipLevelsCount, true );
			_DiffuseAlpha.CopyTo( ReadableDiffuseAlpha );
			DataBox	Data = ReadableDiffuseAlpha.Map( 0 );

			MapPosition2D[,,]	NonEmptyVoxelPositions = new MapPosition2D[_DiffuseAlpha.Width, _DiffuseAlpha.Height, _DiffuseAlpha.Depth];
			for ( int Z=0; Z < ReadableDiffuseAlpha.Depth; Z++ )
				for ( int Y=0; Y < ReadableDiffuseAlpha.Height; Y++ )
					for ( int X=0; X < ReadableDiffuseAlpha.Width; X++ )
						NonEmptyVoxelPositions[X,Y,Z] = new MapPosition2D() { X=0xFFFF, Y=0xFFFF };

			List<VoxelPosition>	NonEmptyVoxels = new List<VoxelPosition>();
			Half4	Voxel;
			for ( int Z=0; Z < ReadableDiffuseAlpha.Depth; Z++ )
				for ( int Y=0; Y < ReadableDiffuseAlpha.Height; Y++ )
					for ( int X=0; X < ReadableDiffuseAlpha.Width; X++ )
					{
						Voxel = Data.Data.ReadHalf4();
						float	Opacity = (float) Voxel.W;
						if ( Opacity < 1e-3f )
							continue;	// Empty...

						NonEmptyVoxelPositions[X,Y,Z].X = (ushort) (NonEmptyVoxels.Count % _Map2DWidth);
						NonEmptyVoxelPositions[X,Y,Z].Y = (ushort) (NonEmptyVoxels.Count / _Map2DWidth);

						NonEmptyVoxels.Add( new VoxelPosition() { X=(byte)X, Y=(byte)Y, Z=(byte)Z } );
					}

			using ( Image3D<PF_RG16> I = new Image3D<PF_RG16>( m_Device, "NonEmptyVoxelsImage", _DiffuseAlpha.Width, _DiffuseAlpha.Height, _DiffuseAlpha.Depth, ( int _X, int _Y, int _Z, ref Vector4 _Color ) =>
			{
				_Color.X = NonEmptyVoxelPositions[_X,_Y,_Z].X / 65535.0f;
				_Color.Y = NonEmptyVoxelPositions[_X,_Y,_Z].Y / 65535.0f;
			}, 1 ) )
				_MapNonEmptyVoxels1 = new Texture3D<PF_RG16>( m_Device, "NonEmptyVoxels3D->2D", I );

			// Determine the size of the 2D map (Map #1) using the provided map width
			int	MapHeight = ((NonEmptyVoxels.Count-1) / _Map2DWidth) + 1;
			VoxelPosition	NonEmptyVoxel;
			using ( Image<PF_RGBA8> I = new Image<PF_RGBA8>( m_Device, "NonEmptyVoxelsImage", _Map2DWidth, MapHeight, ( int _X, int _Y, ref Vector4 _Color ) =>
				{
					int	NonEmptyVoxelIndex = (_Y * _Map2DWidth) + _X;
					if ( NonEmptyVoxelIndex < NonEmptyVoxels.Count )
						NonEmptyVoxel = NonEmptyVoxels[NonEmptyVoxelIndex];
					else
					{	// Out of bounds => Indicate invalid voxel
						NonEmptyVoxel.X = NonEmptyVoxel.Y = NonEmptyVoxel.Z = 255;
					}
					_Color.X = NonEmptyVoxel.X / 255.0f;
					_Color.Y = NonEmptyVoxel.Y / 255.0f;
					_Color.Z = NonEmptyVoxel.Z / 255.0f;
				}, 1 ) )
			{
				_MapNonEmptyVoxels0 = new Texture2D<PF_RGBA8>( m_Device, "NonEmptyVoxels2D->3D", I );
			}

			ReadableDiffuseAlpha.UnMap( 0 );
			ReadableDiffuseAlpha.Dispose();

			//////////////////////////////////////////////////////////////////////////
			// Next, and this is the difficult part, we perform ray-casting for each non-empty voxel in the
			//	scene and compute N intersections that we will store in several render targets.
			// The result of an intersection is a hit coordinate in VOXEL space (XYZ = 3*8bits) so we can
			//	store at most 10 intersections into 8 render targets (8*4 = 32 available slots into which
			//	we can pack 3*10 = 30 ray intersection coordinates)
			//
			RenderTarget<PF_RGBA8>	FormFactors = new RenderTarget<PF_RGBA8>( m_Device, "FormFactors", _Map2DWidth, MapHeight, 1, 8*_RayBundlesCount, 1 );
			_FormFactors = FormFactors;

			// Build a set of equally distributed rays using a Hammersley sequence
			Vector4[][]	RayBundles = new Vector4[_RayBundlesCount][];
			for ( int BundleIndex=0; BundleIndex < _RayBundlesCount; BundleIndex++ )
				RayBundles[BundleIndex] = new Vector4[10];

			int		RaysCount = 10 * _RayBundlesCount;
			double	MaxSinTheta = Math.Sin( _MaxTheta );

			WMath.Hammersley	Ham = new WMath.Hammersley();
			double[,]			HamSequence = Ham.BuildSequence( RaysCount, 2 );

			Vector4	Ray = Vector4.Zero;
			_RayWeights = new float[10*_RayBundlesCount];
			for ( int RayIndex=0; RayIndex < RaysCount; RayIndex++ )
			{
				double	Theta = Math.Asin( MaxSinTheta * HamSequence[RayIndex,0] );
				double	Phi = 2.0 * Math.PI * HamSequence[RayIndex,1];
				Ray.X = (float) (Math.Sin( Phi ) * Math.Sin( Theta ));
				Ray.Y = (float) Math.Cos( Theta );
				Ray.Z = (float) (Math.Cos( Phi ) * Math.Sin( Theta ));

				_RayWeights[RayIndex] = Ray.Y;	// Dot product with normal

				int	BundleIndex = RayIndex / 10;
				int	RayInBundleIndex = RayIndex % 10;
				RayBundles[BundleIndex][RayInBundleIndex] = Ray;
			}

			// Perform ray-casting
			Material<VS_Pt4>	MaterialComputeFormFactors = new Material<VS_Pt4>( m_Device, "ComputeFormFactors Material", ShaderModel.SM4_0, new System.IO.FileInfo( "./FX/VolumeRadiosityBuilder/ComputeFormFactors.fx" ) );
			using ( MaterialComputeFormFactors.UseLock() )
			{
				m_Device.SetStockRasterizerState( Nuaj.Device.HELPER_STATES.NO_CULLING );
				m_Device.SetStockDepthStencilState( Nuaj.Device.HELPER_DEPTH_STATES.DISABLED );
				m_Device.SetStockBlendState( Nuaj.Device.HELPER_BLEND_STATES.DISABLED );

				MaterialComputeFormFactors.GetVariableByName( "NonEmptyVoxelsPositions" ).AsResource.SetResource( _MapNonEmptyVoxels0 );
				MaterialComputeFormFactors.GetVariableByName( "DiffuseField" ).AsResource.SetResource( _DiffuseAlpha );
				MaterialComputeFormFactors.GetVariableByName( "NormalField" ).AsResource.SetResource( _Normal );
				MaterialComputeFormFactors.GetVariableByName( "DistanceField" ).AsResource.SetResource( _DistanceField );
				MaterialComputeFormFactors.GetVariableByName( "VolumeInvSize" ).AsVector.Set( _DistanceField.InvSize4 );
				MaterialComputeFormFactors.GetVariableByName( "BufferInvSize" ).AsVector.Set( FormFactors.InvSize3 );
				MaterialComputeFormFactors.GetVariableByName( "OffsetOffWalls" ).AsScalar.Set( _OffsetOffWalls );

				RenderTargetView[]	MRT = new RenderTargetView[8];
				for ( int RayBundleIndex=0; RayBundleIndex < _RayBundlesCount; RayBundleIndex++ )
				{
					// Render into 8 render targets at the same time !
					for ( int RTIndex=0; RTIndex < 8; RTIndex++ )
						MRT[RTIndex] = FormFactors.GetSingleRenderTargetView( 0, 8*RayBundleIndex+RTIndex );
					m_Device.SetMultipleRenderTargets( MRT );

					// Setup rays for this bundle
					MaterialComputeFormFactors.GetVariableByName( "Rays" ).AsVector.Set( RayBundles[RayBundleIndex] );

					// Render quad
					MaterialComputeFormFactors.ApplyPass( 0 );
					m_Quad.Render();

					// We now are the proud owners of 10 ray intersections stored into 8 render targets (i.e. 8 array slices really)
					
					// Alleviate device load
					m_Device.DirectXDevice.Flush();
				}
			}
			MaterialComputeFormFactors.Dispose();
		}

		#endregion

		#region Volume Radiosity Runtime

		// Materials
		protected Material<VS_Pt4>				m_MaterialDirectLighting = null;
		protected Material<VS_Pt4>				m_MaterialComputeRadiosity = null;

		// Source textures for radiosity computation
		protected Vector3						m_VolumeOrigin = Vector3.Zero;
		protected float							m_VoxelSize = 0.0f;
		protected int							m_RayBundlesCount = 0;
		protected double						m_MaxTheta = 0.0;
		protected float[]						m_RayWeights = null;

		protected Texture2D<PF_RGBA8>			m_MapNonEmptyVoxels0 = null;
		protected Texture3D<PF_RG16>			m_MapNonEmptyVoxels1 = null;
		protected Texture2D<PF_RGBA8>			m_FormFactors = null;

		// Targets for realtime radiosity computation
		protected RenderTarget<PF_RGBA16F>		m_DirectIrradiance2D = null;
		protected RenderTarget3D<PF_RGBA16F>[]	m_Irradiance = new RenderTarget3D<PF_RGBA16F>[2];
		protected RenderTarget3D<PF_RGBA16F>[]	m_IrradianceResult = new RenderTarget3D<PF_RGBA16F>[2];

		protected void	InitRadiosity( Vector3 _VolumeOrigin, float _VoxelSize, int _RayBundlesCount, double _MaxTheta, float[] _RayWeights, Texture2D<PF_RGBA8> _MapNonEmptyVoxels0, Texture3D<PF_RG16> _MapNonEmptyVoxels1, Texture2D<PF_RGBA8> _FormFactors )
		{
			// Store work textures & data
			m_VolumeOrigin = _VolumeOrigin;
			m_VoxelSize = _VoxelSize;
			m_RayBundlesCount = _RayBundlesCount;
			m_MaxTheta = _MaxTheta;
			m_RayWeights = _RayWeights;
			m_MapNonEmptyVoxels0 = _MapNonEmptyVoxels0;
			m_MapNonEmptyVoxels1 = _MapNonEmptyVoxels1;
			m_FormFactors = _FormFactors;

			// Build materials
			m_MaterialDirectLighting = ToDispose( new Material<VS_Pt4>( m_Device, "Compute Direct Lighting", ShaderModel.SM4_0, new System.IO.FileInfo( "./FX/VolumeRadiosityBuilder/UserComputeDirectLighting.fx" ) ) );
			m_MaterialComputeRadiosity = ToDispose( new Material<VS_Pt4>( m_Device, "Compute Radiosity", ShaderModel.SM4_0, new System.IO.FileInfo( "./FX/VolumeRadiosityBuilder/ComputeRadiosity.fx" ) ) );

			// Build render targets used for radiosity computation
			m_DirectIrradiance2D = ToDispose( new RenderTarget<PF_RGBA16F>( m_Device, "DirectIrradiance2D", _MapNonEmptyVoxels0.Width, _MapNonEmptyVoxels0.Height, 1 ) );
			m_Irradiance[0] = ToDispose( new RenderTarget3D<PF_RGBA16F>( m_Device, "Irradiance#0", _MapNonEmptyVoxels1.Width, _MapNonEmptyVoxels1.Height, _MapNonEmptyVoxels1.Depth, 0 ) );
			m_Irradiance[1] = ToDispose( new RenderTarget3D<PF_RGBA16F>( m_Device, "Irradiance#1", _MapNonEmptyVoxels1.Width, _MapNonEmptyVoxels1.Height, _MapNonEmptyVoxels1.Depth, 0 ) );
			m_IrradianceResult[0] = ToDispose( new RenderTarget3D<PF_RGBA16F>( m_Device, "ResultIrradiance", _MapNonEmptyVoxels1.Width, _MapNonEmptyVoxels1.Height, _MapNonEmptyVoxels1.Depth, 0 ) );
			m_IrradianceResult[1] = ToDispose( new RenderTarget3D<PF_RGBA16F>( m_Device, "ResultIrradiance", _MapNonEmptyVoxels1.Width, _MapNonEmptyVoxels1.Height, _MapNonEmptyVoxels1.Depth, 0 ) );
		}

		/// <summary>
		/// This is the actual radiosity update method
		/// </summary>
		public TimeSpan		UpdateRadiosity( int _BouncesCount, Vector3 _EnvironmentColor )
		{
			DateTime	StartTime = DateTime.Now;

			m_Device.SetStockRasterizerState( Nuaj.Device.HELPER_STATES.NO_CULLING );
			m_Device.SetStockDepthStencilState( Nuaj.Device.HELPER_DEPTH_STATES.DISABLED );
			m_Device.SetStockBlendState( Nuaj.Device.HELPER_BLEND_STATES.DISABLED );

			//////////////////////////////////////////////////////////////////////////
			// 1] Compute direct irradiance map
			// This should be done by the user with his own renderer since we only ask him
			//	to light a bunch of points, given their position and normal in the world.
			// Any renderer should be able to do that...
			//
			using ( m_MaterialDirectLighting.UseLock() )
			{
				m_Device.SetRenderTarget( m_DirectIrradiance2D );
				m_Device.SetViewport( 0, 0, m_DirectIrradiance2D.Width, m_DirectIrradiance2D.Height, 0.0f, 1.0f );

				m_MaterialDirectLighting.GetVariableByName( "BufferInvSize" ).AsVector.Set( m_MapNonEmptyVoxels0.InvSize3 );
				m_MaterialDirectLighting.GetVariableByName( "VolumeInvSize" ).AsVector.Set( m_MapNonEmptyVoxels1.InvSize3 );
				m_MaterialDirectLighting.GetVariableByName( "VolumeOrigin" ).AsVector.Set( m_VolumeOrigin );
				m_MaterialDirectLighting.GetVariableByName( "VoxelSize" ).AsScalar.Set( m_VoxelSize );
				m_MaterialDirectLighting.GetVariableByName( "NonEmptyVoxelsPositions" ).AsResource.SetResource( m_MapNonEmptyVoxels0 );
				m_MaterialDirectLighting.GetVariableByName( "NormalField" ).AsResource.SetResource( m_Normal );
				m_MaterialDirectLighting.GetVariableByName( "DiffuseField" ).AsResource.SetResource( m_DiffuseAlpha );

				// User parameters
				m_MaterialDirectLighting.GetVariableByName( "LightDirection" ).AsVector.Set( m_RenderScene.LightDirection );
				m_MaterialDirectLighting.GetVariableByName( "LightColor" ).AsVector.Set( m_RenderScene.LightColor );

				m_MaterialDirectLighting.ApplyPass( 0 );
				m_Quad.Render();
			}

			Material<VS_Pt4>	M = m_MaterialComputeRadiosity;
			using ( m_MaterialComputeRadiosity.UseLock() ) 
			{
				//////////////////////////////////////////////////////////////////////////
				// 2] Build a 3D irradiance map from that 2D map
				// Each non empty 3D voxel will be painted with the irradiance computed by stage 1]
				//
				M.CurrentTechnique = M.GetTechniqueByName( "Build3DIrradianceFrom2DMap" );

				m_Device.SetRenderTarget( m_Irradiance[0] );
				m_Device.SetViewport( 0, 0, m_Irradiance[0].Width, m_Irradiance[0].Height, 0.0f, 1.0f );

				M.GetVariableByName( "DirectIrradianceMapInvSize" ).AsVector.Set( m_DirectIrradiance2D.InvSize2 );
				M.GetVariableByName( "DirectIrradiance" ).AsResource.SetResource( m_DirectIrradiance2D );
				M.GetVariableByName( "VolumeInvSize" ).AsVector.Set( m_Irradiance[0].InvSize3 );
				M.GetVariableByName( "Volume" ).AsResource.SetResource( m_MapNonEmptyVoxels1 );
				M.GetVariableByName( "SliceOffset" ).AsScalar.Set( 0 );

				M.ApplyPass(0);
				m_Quad.RenderInstanced( 0, m_Irradiance[0].Depth );

				//////////////////////////////////////////////////////////////////////////
				// 3] Build irradiance mip maps
				BuildMipMaps( m_Irradiance[0] );


				//////////////////////////////////////////////////////////////////////////
				// 4] Perform multiple bounce reflections
				// 
				M.GetVariableByName( "DiffuseField" ).AsResource.SetResource( m_DiffuseAlpha );
				M.GetVariableByName( "NormalField" ).AsResource.SetResource( m_Normal );
				M.GetVariableByName( "VolumeTo2D" ).AsResource.SetResource( m_MapNonEmptyVoxels1 );
				M.GetVariableByName( "FormFactorsMapInvSize" ).AsVector.Set( m_FormFactors.InvSize2 );
				M.GetVariableByName( "FormFactors" ).AsResource.SetResource( m_FormFactors );
				M.GetVariableByName( "RayBundlesCount" ).AsScalar.Set( m_RayBundlesCount );
				M.GetVariableByName( "RaySolidAngle" ).AsScalar.Set( ComputeRaySolidAngle() );
				M.GetVariableByName( "VoxelSize" ).AsScalar.Set( m_VoxelSize );
				M.GetVariableByName( "VoxelInvSize" ).AsScalar.Set( 1.0f / m_VoxelSize );
				M.GetVariableByName( "RayWeights" ).AsScalar.Set( m_RayWeights );

				m_Device.ClearRenderTarget( m_IrradianceResult[0], Vector4.Zero );

				for ( int BounceIndex=0; BounceIndex < _BouncesCount; BounceIndex++ )
				{
					// 4.1] Perform gathering of irradiance into a target
					// Here, we render each slice of the 3D target and for each non empty
					//	voxel we use the map of form factors to gather irradiance from
					//	neighbor surfaces
					M.CurrentTechnique = M.GetTechniqueByName( "GatherIrradiance" );
					m_Device.SetRenderTarget( m_Irradiance[1] );
					m_Device.SetViewport( 0, 0, m_Irradiance[1].Width, m_Irradiance[1].Height, 0.0f, 1.0f );
					M.GetVariableByName( "Volume" ).AsResource.SetResource( m_Irradiance[0] );
					M.GetVariableByName( "VolumeInvSize" ).AsVector.Set( m_Irradiance[0].InvSize3 );
					M.GetVariableByName( "SliceOffset" ).AsScalar.Set( 0 );
					M.GetVariableByName( "EnvironmentColor" ).AsVector.Set( BounceIndex == 0 ? _EnvironmentColor : Vector3.Zero );
					M.ApplyPass(0);
					m_Quad.RenderInstanced( 0, m_Irradiance[1].Depth );

					// 4.2] Build irradiance mip maps
					BuildMipMaps( m_Irradiance[1] );

					// 4.3] Accumulate irradiance into final target
					m_Device.SetStockBlendState( Nuaj.Device.HELPER_BLEND_STATES.ADDITIVE );
					M.CurrentTechnique = M.GetTechniqueByName( "AccumulateIrradiance" );
					m_Device.SetRenderTarget( m_IrradianceResult[0] );
					m_Device.SetViewport( 0, 0, m_Irradiance[0].Width, m_Irradiance[0].Height, 0.0f, 1.0f );
					M.GetVariableByName( "Volume" ).AsResource.SetResource( m_Irradiance[1] );
					M.GetVariableByName( "VolumeInvSize" ).AsVector.Set( m_Irradiance[1].InvSize3 );
					M.GetVariableByName( "SliceOffset" ).AsScalar.Set( 0 );
					M.ApplyPass(0);
					m_Quad.RenderInstanced( 0, m_IrradianceResult[0].Depth );
					m_Device.SetStockBlendState( Nuaj.Device.HELPER_BLEND_STATES.DISABLED );

					// 4.4] Swap irradiance buffers for next bounce
					RenderTarget3D<PF_RGBA16F>	Temp = m_Irradiance[0];
					m_Irradiance[0] = m_Irradiance[1];
					m_Irradiance[1] = Temp;
				}

				// TODO: Gaussian smooth out result
				// For the moment, I'm using the ugly mipmaps...

				//////////////////////////////////////////////////////////////////////////
				// 5] Build final irradiance target mip maps
				//
				BuildMipMaps( m_IrradianceResult[0] );
			}

			// Finally, the 3D map of indirect lighting is ready
			// Feel free to query it as you like, in world space or screen space as a post-process for a deferred renderer...

			DateTime	EndTime = DateTime.Now;
			return EndTime - StartTime;
		}

		protected enum RADIOSITY_UPDATE_STAGE
		{
			COMPUTE_DIRECT_IRRADIANCE,				// Direct irradiance cannot be split (well, it could but I don't want to)
			TRANSFER_DIRECT_IRRADIANCE_TO_VOLUME,	// Transfer the direct irradiance from the 2D map to the 3D volume
			BUILD_DIRECT_IRRADIANCE_MIP_MAPS,		// Build mip maps for previous stage
			COMPUTE_LIGHT_BOUNCES,					// Computes multiple light bounces
			BUILD_RESULT_IRRADIANCE_MIP_MAPS,		// Build mip maps for the result and we're done !
		}

		protected enum RADIOSITY_UPDATE_SUBSTAGE
		{
			GATHER_IRRADIANCE,
			BUILD_MIP_MAPS,
			ACCUMULATE,
			END
		}

		protected int						m_RadiosityUpdateCallsCount = 0;
		protected double					m_RadiosityUpdateUpdateTime = 0.0f;
		protected RADIOSITY_UPDATE_STAGE	m_RadiosityUpdateStage = RADIOSITY_UPDATE_STAGE.COMPUTE_DIRECT_IRRADIANCE;
		protected RADIOSITY_UPDATE_SUBSTAGE	m_RadiosityUpdateSubStage = RADIOSITY_UPDATE_SUBSTAGE.GATHER_IRRADIANCE;
		protected int						m_RadiosityUpdateBounceIndex = 0;
		protected int						m_RadiosityUpdateSliceIndex = 0;

		/// <summary>
		/// This is the actual radiosity update method with time slicing for fast update
		/// </summary>
		/// <param name="_BouncesCount">Amount of light bounces to perform</param>
		/// <param name="_EnvironmentColor">The color to use for the environement (i.e. sky color)</param>
		/// <param name="_Milliseconds">The maximum amount of milliseconds we want to spend in the function per call</param>
		/// <param name="_GatheringSlicesCountPerDrawCall">The amount of slices rendered by the gathering stage each time it performs a draw call (1 draws slice by slice, 10 draws by bunch of 10 slices, etc.)
		/// It's advised to set this value to a low setting if you know each slice is intensive (like when you have many points to light and a large amount of ray bundles)</param>
		/// <param name="_UpdateTime">The time spent in the time sliced update (shouldn't be much above the specified milliseconds count)</param>
		/// <param name="_CallsCount">The amount of calls to the function that were necessary for a full update</param>
		/// <param name="_TotalUpdateTime">The total time spent in a full update</param>
		/// <returns>True if the update is complete</returns>
		public bool		UpdateRadiosityTimeSliced( int _BouncesCount, Vector3 _EnvironmentColor, float _Milliseconds, int _GatheringSlicesCountPerDrawCall, out TimeSpan _UpdateTime, ref int _CallsCount, ref double _TotalUpdateTime )
		{
			DateTime	StartTime = DateTime.Now;
			bool		bFullUpdate = false;
			m_RadiosityUpdateCallsCount++;

			m_Device.SetStockRasterizerState( Nuaj.Device.HELPER_STATES.NO_CULLING );
			m_Device.SetStockDepthStencilState( Nuaj.Device.HELPER_DEPTH_STATES.DISABLED );
			m_Device.SetStockBlendState( Nuaj.Device.HELPER_BLEND_STATES.DISABLED );

			Material<VS_Pt4>	M = m_MaterialComputeRadiosity;
			IDisposable			MaterialLock = null;
			do
			{
				// Check if we should be locking the main material
				if ( MaterialLock == null && m_RadiosityUpdateStage > RADIOSITY_UPDATE_STAGE.COMPUTE_DIRECT_IRRADIANCE )
					MaterialLock = M.UseLock();

				switch ( m_RadiosityUpdateStage )
				{
					//////////////////////////////////////////////////////////////////////////
					// 1] Compute direct irradiance map
					// This should be done by the user with his own renderer since we only ask him
					//	to light a bunch of points, given their position and normal in the world.
					// Any renderer should be able to do that...
					//
					case RADIOSITY_UPDATE_STAGE.COMPUTE_DIRECT_IRRADIANCE:
						{
							using ( m_MaterialDirectLighting.UseLock() )
							{
								m_Device.SetRenderTarget( m_DirectIrradiance2D );
								m_Device.SetViewport( 0, 0, m_DirectIrradiance2D.Width, m_DirectIrradiance2D.Height, 0.0f, 1.0f );

								m_MaterialDirectLighting.GetVariableByName( "BufferInvSize" ).AsVector.Set( m_MapNonEmptyVoxels0.InvSize3 );
								m_MaterialDirectLighting.GetVariableByName( "VolumeInvSize" ).AsVector.Set( m_MapNonEmptyVoxels1.InvSize3 );
								m_MaterialDirectLighting.GetVariableByName( "VolumeOrigin" ).AsVector.Set( m_VolumeOrigin );
								m_MaterialDirectLighting.GetVariableByName( "VoxelSize" ).AsScalar.Set( m_VoxelSize );
								m_MaterialDirectLighting.GetVariableByName( "NonEmptyVoxelsPositions" ).AsResource.SetResource( m_MapNonEmptyVoxels0 );
								m_MaterialDirectLighting.GetVariableByName( "NormalField" ).AsResource.SetResource( m_Normal );
								m_MaterialDirectLighting.GetVariableByName( "DiffuseField" ).AsResource.SetResource( m_DiffuseAlpha );

								// User parameters
								m_MaterialDirectLighting.GetVariableByName( "LightDirection" ).AsVector.Set( m_RenderScene.LightDirection );
								m_MaterialDirectLighting.GetVariableByName( "LightColor" ).AsVector.Set( m_RenderScene.LightColor );

								m_MaterialDirectLighting.ApplyPass( 0 );
								m_Quad.Render();
							}

							m_RadiosityUpdateStage++;	// Go to next stage...
							break;
						}

					//////////////////////////////////////////////////////////////////////////
					// 2] Build a 3D irradiance map from that 2D map
					// Each non empty 3D voxel will be painted with the irradiance computed by stage 1]
					//
					case RADIOSITY_UPDATE_STAGE.TRANSFER_DIRECT_IRRADIANCE_TO_VOLUME:
						{
							M.CurrentTechnique = M.GetTechniqueByName( "Build3DIrradianceFrom2DMap" );

							m_Device.SetRenderTarget( m_Irradiance[0] );
							m_Device.SetViewport( 0, 0, m_Irradiance[0].Width, m_Irradiance[0].Height, 0.0f, 1.0f );

							M.GetVariableByName( "DirectIrradianceMapInvSize" ).AsVector.Set( m_DirectIrradiance2D.InvSize2 );
							M.GetVariableByName( "DirectIrradiance" ).AsResource.SetResource( m_DirectIrradiance2D );
							M.GetVariableByName( "VolumeInvSize" ).AsVector.Set( m_Irradiance[0].InvSize3 );
							M.GetVariableByName( "Volume" ).AsResource.SetResource( m_MapNonEmptyVoxels1 );
							M.GetVariableByName( "SliceOffset" ).AsScalar.Set( 0 );

							M.ApplyPass(0);
							m_Quad.RenderInstanced( 0, m_Irradiance[0].Depth );

							m_RadiosityUpdateStage++;	// Go to next stage...
							break;
						}

					//////////////////////////////////////////////////////////////////////////
					// 3] Build irradiance mip maps & clear result
					case RADIOSITY_UPDATE_STAGE.BUILD_DIRECT_IRRADIANCE_MIP_MAPS:
						{
							BuildMipMaps( m_Irradiance[0] );
							m_Device.ClearRenderTarget( m_IrradianceResult[1], Vector4.Zero );

							m_RadiosityUpdateStage++;	// Go to next stage...
							m_RadiosityUpdateSubStage = _BouncesCount > 0 ? RADIOSITY_UPDATE_SUBSTAGE.GATHER_IRRADIANCE : RADIOSITY_UPDATE_SUBSTAGE.END;
							m_RadiosityUpdateBounceIndex = 0;
							m_RadiosityUpdateSliceIndex = 0;
							break;
						}

					//////////////////////////////////////////////////////////////////////////
					// 4] Perform multiple bounce reflections
					// 
					case RADIOSITY_UPDATE_STAGE.COMPUTE_LIGHT_BOUNCES:
						{
							do
							{
								switch ( m_RadiosityUpdateSubStage )
								{
									// 4.1] Perform gathering of irradiance into a target
									// Here, we render each slice of the 3D target and for each non empty
									//	voxel we use the map of form factors to gather irradiance from
									//	neighbor surfaces
									case RADIOSITY_UPDATE_SUBSTAGE.GATHER_IRRADIANCE:
										{
											M.CurrentTechnique = M.GetTechniqueByName( "GatherIrradiance" );
											EffectPass	P = M.CurrentTechnique.GetPassByIndex(0);

											m_Device.SetRenderTarget( m_Irradiance[1] );
											m_Device.SetViewport( 0, 0, m_Irradiance[1].Width, m_Irradiance[1].Height, 0.0f, 1.0f );

											M.GetVariableByName( "DiffuseField" ).AsResource.SetResource( m_DiffuseAlpha );
											M.GetVariableByName( "NormalField" ).AsResource.SetResource( m_Normal );
											M.GetVariableByName( "VolumeTo2D" ).AsResource.SetResource( m_MapNonEmptyVoxels1 );
											M.GetVariableByName( "FormFactorsMapInvSize" ).AsVector.Set( m_FormFactors.InvSize2 );
											M.GetVariableByName( "FormFactors" ).AsResource.SetResource( m_FormFactors );
											M.GetVariableByName( "RayBundlesCount" ).AsScalar.Set( m_RayBundlesCount );
											M.GetVariableByName( "RaySolidAngle" ).AsScalar.Set( ComputeRaySolidAngle() );
											M.GetVariableByName( "VoxelSize" ).AsScalar.Set( m_VoxelSize );
											M.GetVariableByName( "VoxelInvSize" ).AsScalar.Set( 1.0f / m_VoxelSize );
											M.GetVariableByName( "RayWeights" ).AsScalar.Set( m_RayWeights );
											M.GetVariableByName( "GatherMipBias" ).AsScalar.Set( floatTrackbarControlGatheringMipBias.Value );
											M.GetVariableByName( "Volume" ).AsResource.SetResource( m_Irradiance[0] );
											M.GetVariableByName( "VolumeInvSize" ).AsVector.Set( m_Irradiance[0].InvSize3 );
											M.GetVariableByName( "EnvironmentColor" ).AsVector.Set( m_RadiosityUpdateBounceIndex == 0 ? _EnvironmentColor : Vector3.Zero );

											VariableScalar	vSliceOffset = M.GetVariableByName( "SliceOffset" ).AsScalar;

											do
											{
												vSliceOffset.Set( m_RadiosityUpdateSliceIndex );
												P.Apply();

												int	SlicesCount = Math.Min( m_Irradiance[1].Depth - m_RadiosityUpdateSliceIndex, _GatheringSlicesCountPerDrawCall );
												m_Quad.RenderInstanced( 0, SlicesCount );

												m_RadiosityUpdateSliceIndex += SlicesCount;

												_UpdateTime = DateTime.Now - StartTime;

											} while ( m_RadiosityUpdateSliceIndex < m_Irradiance[1].Depth && _UpdateTime.TotalMilliseconds < _Milliseconds ); 

											if ( m_RadiosityUpdateSliceIndex == m_Irradiance[1].Depth )
												m_RadiosityUpdateSubStage++;	// Go to next stage...

// 											m_Quad.RenderInstanced( 0, m_Irradiance[1].Depth );
//											m_RadiosityUpdateSubStage++;	// Go to next stage...

											break;
										}

									// 4.2] Build irradiance mip maps
									case RADIOSITY_UPDATE_SUBSTAGE.BUILD_MIP_MAPS:
										{
											BuildMipMaps( m_Irradiance[1] );

											m_RadiosityUpdateSubStage++;
											break;
										}

									// 4.3] Accumulate irradiance into final target
									case RADIOSITY_UPDATE_SUBSTAGE.ACCUMULATE:
										{
											m_Device.SetStockBlendState( Nuaj.Device.HELPER_BLEND_STATES.ADDITIVE );
											M.CurrentTechnique = M.GetTechniqueByName( "AccumulateIrradiance" );

											m_Device.SetRenderTarget( m_IrradianceResult[1] );
											m_Device.SetViewport( 0, 0, m_Irradiance[1].Width, m_Irradiance[1].Height, 0.0f, 1.0f );

											M.GetVariableByName( "Volume" ).AsResource.SetResource( m_Irradiance[1] );
											M.GetVariableByName( "VolumeInvSize" ).AsVector.Set( m_Irradiance[1].InvSize3 );
											M.GetVariableByName( "SliceOffset" ).AsScalar.Set( 0 );

											M.ApplyPass(0);
											m_Quad.RenderInstanced( 0, m_IrradianceResult[1].Depth );

											m_Device.SetStockBlendState( Nuaj.Device.HELPER_BLEND_STATES.DISABLED );

											// Swap irradiance buffers for next bounce
											RenderTarget3D<PF_RGBA16F>	Temp = m_Irradiance[0];
											m_Irradiance[0] = m_Irradiance[1];
											m_Irradiance[1] = Temp;

											m_RadiosityUpdateBounceIndex++;		// One more bounce
											if ( m_RadiosityUpdateBounceIndex < _BouncesCount )
											{	// Start another bounce
												m_RadiosityUpdateSubStage = RADIOSITY_UPDATE_SUBSTAGE.GATHER_IRRADIANCE;
												m_RadiosityUpdateSliceIndex = 0;	// Reset slices
											}
											else
												m_RadiosityUpdateSubStage = RADIOSITY_UPDATE_SUBSTAGE.END;	// We're done !
											break;
										}
								}

								_UpdateTime = DateTime.Now - StartTime;
							} while ( m_RadiosityUpdateSubStage != RADIOSITY_UPDATE_SUBSTAGE.END && _UpdateTime.TotalMilliseconds < _Milliseconds );

							if ( m_RadiosityUpdateSubStage == RADIOSITY_UPDATE_SUBSTAGE.END )
								m_RadiosityUpdateStage++;	// Go to next stage...
							break;
						}


					//////////////////////////////////////////////////////////////////////////
					// 5] Build final irradiance target mip maps
					//
					case RADIOSITY_UPDATE_STAGE.BUILD_RESULT_IRRADIANCE_MIP_MAPS:
						{
							BuildMipMaps( m_IrradianceResult[1] );

							// Swap results
							RenderTarget3D<PF_RGBA16F>	Temp = m_IrradianceResult[0];
							m_IrradianceResult[0] = m_IrradianceResult[1];
							m_IrradianceResult[1] = Temp;

							// We're done ! Rewind stage and update final count...
							_CallsCount = m_RadiosityUpdateCallsCount;			// We now have the final count of calls for a full update

							_UpdateTime = DateTime.Now - StartTime;
							_TotalUpdateTime = m_RadiosityUpdateUpdateTime + _UpdateTime.TotalMilliseconds;	// And the final count of total milliseconds for a full update

							m_RadiosityUpdateStage = RADIOSITY_UPDATE_STAGE.COMPUTE_DIRECT_IRRADIANCE;	// Go back to first stage
							m_RadiosityUpdateCallsCount = 0;	// Reset count
							m_RadiosityUpdateUpdateTime = 0.0;	// and time
							bFullUpdate = true;	// We have a full update
							break;
						}
				}

				// Check time
				_UpdateTime = DateTime.Now - StartTime;
			} while ( _UpdateTime.TotalMilliseconds < _Milliseconds && !bFullUpdate );

			// Accumulate update time
			m_RadiosityUpdateUpdateTime += _UpdateTime.TotalMilliseconds;

			// Release the lock
			if ( MaterialLock != null )
				MaterialLock.Dispose();

			return bFullUpdate;
		}

		/// <summary>
		/// Build all the mip levels of a given 3D texture
		/// </summary>
		/// <param name="_Target"></param>
		protected void	BuildMipMaps( IRenderTarget3D _Target )
		{
			Material<VS_Pt4>	M = m_MaterialComputeRadiosity;
			M.CurrentTechnique = M.GetTechniqueByName( "BuildMipMaps" );
			EffectPass	P = M.CurrentTechnique.GetPassByIndex( 0 );

			M.GetVariableByName( "SliceOffset" ).AsScalar.Set( 0 );
			VariableVector		vVolumeInvSize = M.GetVariableByName( "VolumeInvSize" ).AsVector;
			VariableVector		vPrevVolumeInvSize = M.GetVariableByName( "PrevVolumeInvSize" ).AsVector;
			VariableResource	vVolume = M.GetVariableByName( "Volume" ).AsResource;

			int	CurrentWidth = _Target.Width;
			int	CurrentHeight = _Target.Height;
			int	CurrentDepth = _Target.Depth;
			Vector3	VolumeInvSize = new Vector3( 1.0f / CurrentWidth, 1.0f / CurrentHeight, 1.0f / CurrentDepth );
			for ( int MipIndex=1; MipIndex < _Target.MipLevelsCount; MipIndex++ )
			{
				CurrentWidth = Math.Max( 1, CurrentWidth >> 1 );
				CurrentHeight = Math.Max( 1, CurrentHeight >> 1 );
				CurrentDepth = Math.Max( 1, CurrentDepth >> 1 );

				m_Device.SetRenderTarget( _Target.GetSingleRenderTargetView( MipIndex ) );
				m_Device.SetViewport( 0, 0, CurrentWidth, CurrentHeight, 0.0f, 1.0f );

				vPrevVolumeInvSize.Set( VolumeInvSize );
				VolumeInvSize = new Vector3( 1.0f / CurrentWidth, 1.0f / CurrentHeight, 1.0f / CurrentDepth );
				vVolumeInvSize.Set( VolumeInvSize );
				vVolume.SetResource( _Target.GetSingleTextureView( MipIndex-1 ) );

				P.Apply();
				m_Quad.RenderInstanced( 0, _Target.Depth );
			}
		}

		/// <summary>
		/// The rays are equally distributed in a spherical cap whose max theta angle is know.
		/// Rays are cast in bundles of 10 so we assume the solid angle sustaind by each ray is
		///  simply the surface of the spherical cap divided by the total amount of rays...
		/// </summary>
		/// <returns></returns>
		protected float		ComputeRaySolidAngle()
		{
			return (float) (2.0 * Math.PI * (1-Math.Cos( m_MaxTheta ))) / (10 * m_RayBundlesCount);
		}

		#endregion

		protected void	ReadTexParams( System.IO.Stream _Stream, out int _VolumeWidth, out int _VolumeHeight, out int _VolumeDepth, out float _VoxelSize, out BoundingBox _SceneBBox, out bool _PremultipliedAlpha )
		{
			System.IO.BinaryReader	Reader = new System.IO.BinaryReader( _Stream );

			_VolumeWidth = Reader.ReadInt32();
			_VolumeHeight = Reader.ReadInt32();
			_VolumeDepth = Reader.ReadInt32();
			_VoxelSize = Reader.ReadSingle();
			_SceneBBox = new BoundingBox(
				new Vector3( Reader.ReadSingle(), Reader.ReadSingle(), Reader.ReadSingle() ),
				new Vector3( Reader.ReadSingle(), Reader.ReadSingle(), Reader.ReadSingle() ) );
			_PremultipliedAlpha = Reader.ReadBoolean();
		}

		#region IShaderInterfaceProvider Members

		public void ProvideData( IShaderInterface _Interface )
		{
			IVolumeRadiosity	I = _Interface as IVolumeRadiosity;
			I.FieldOrigin = m_VolumeOrigin;
			I.VoxelSize = m_VoxelSize;
			I.VoxelInvSize = 1.0f / m_VoxelSize;
			I.MipBias = floatTrackbarControlDisplayMipBias.Value;
			I.VolumeInvSize = m_IrradianceResult[0].InvSize3;
			I.IndirectLightingField = m_IrradianceResult[0];
//			I.IndirectLightingField = m_Irradiance[0];		// Debug irradiance
			I.DistanceField = m_DistanceField;
			I.DiffuseField = m_DiffuseAlpha;
		}

		#endregion

		protected override void OnKeyDown( KeyEventArgs e )
		{
			base.OnKeyDown( e );

			switch ( e.KeyCode )
			{
				case Keys.F1:
					m_bDrawInfos = !m_bDrawInfos;
					break;
			}
		}

		#endregion

		#region EVENT HANDLERS

		private void buttonProfiler_Click( object sender, EventArgs e )
		{
			m_Profiler.Show( this );
		}

		#endregion
	}
}
