
//////////////////////////////////////////////////////////////////////////
//
// This little application allows you to render a mesh (a FBX scene) into a 3D render target.
// It's been written for the implementation of the http://www.antisphere.com/Research/VolumetricBillboards.php 2009 paper,
//	an improvement over http://www.antisphere.com/Research/Publis/RealtimeForest_egsr04.pdf (2004).
//
// As explained in the papers, the meshes are rendered using orthographic cameras aligned for the 6 main directions (i.e. +/- X,Y,Z).
// Each camera renders the meshes slice by slice in a stack of 2D slices by adjusting the near/far clip ranges.
//
// Mip maps are generated by standard filtering of each slice => a pixel is averaged with its 3 neighbors in the same slice (as for classical downscaling).
// The trick is that 2 slices are NOT averaged together but rather alpha-blended, as if viewing through the first slice standing in front of the second one.
//
// Finally, we obtain 6 stacks of mip-mapped slices that we'll merge together into a single 3D texture using a mixing function of our choice.
// For example, we could simply average the 6 texels together to form a single voxel. But we can also use the MAX() operator to maximise
//	sharpness and details (that's what I'm using right now) or even take the pixel whose normal length is the largest...
//
//////////////////////////////////////////////////////////////////////////


#define DISPLAY_WITH_RAY_MARCHING	// Use ray-marching to display the volumes, otherwise use slices
//#define DEBUG_SLICES				// When using ray-marching, you can debug slices

//#define LOAD_3D_TEXTURES			// Reload or generate ?

// Here you can configure how to use different techniques that all result more or less in the same framerate
// DRAW_SLICE_BY_SLICE :
//	You can decide to either draw slice by slice, changing boxes at each slice. This generates the largest amount of draw calls (BoxeCount * SlicesCount in fact)
//  Or you can choose to draw box by box, this results in BoxesCount draw calls, each draw call drawing SlicesCount at a single time.
// 
// SLICE_BOXES :
//	This enables or disables the box slicing algorithm.
//	If enabled, each slice at a given Z cuts a box and generates as many triangles
//	 as necessary, resulting in more geometry but this geometry tightly follows the boxes' volumes.
//  If disabled, each slice at a given Z issues a quad that encompasses the box in camera space,
//	 this results in geometry that is larger than the boxes but the generated UVW coordinates can
//	 easily and quickly be clipped out, preventing the pixel shader from processing a pixel whose
//	 UVW are outside the [0,1] range, using a GS that also is simpler and faster.
// 
// USE_ALPHA2COVERAGE :
//  This decides if we should draw in back to front order with BLEND mode, or front to back order with ALPHA TO COVERAGE mode and depth test
// 
// 
// Despite the numerous possible configurations here, my conclusion is that the bottleneck doesn't lie in the
//	geometry generation, transform or draw cals amount but really in the volume texture sampling !
// 
// ----------------------------------------------------------------------------------------------------------- 
// No matter what you do though, drawing a fullscreen slice of 3D texture takes a LOT OF TIME (!!).
// This technique is absolutely not suited for close view of geometry. I would definitely recommend
//	it as an intermediate LOD between full mesh view at close range and billboard view at far range.
// (and I would also wait a few years for graphic cards to be able to easily process many 3D textures)
// ----------------------------------------------------------------------------------------------------------- 
// 
//#define DRAW_SLICE_BY_SLICE			// Draw slice by slice without enabling depth testing, otherwise draw box by box with depth testing (less draw calls but same lousy framerate for chrissake !)
//#define SLICE_BOXES					// Use the prism slicing algorithm, otherwise draw bounding slices
//#define USE_ALPHA2COVERAGE			// Use this to draw in front to back order using alpha to coverage instead of blend mode

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Windows.Forms;

using SharpDX;
using SharpDX.Direct3D10;
using SharpDX.DXGI;

using Nuaj;
using Nuaj.Cirrus;
using Nuaj.Cirrus.FBX;

namespace VolumeMeshBuilder
{
	public partial class VolumeMeshForm : Form
	{
		#region CONSTANTS

		// Volume generation
		protected const int		VOLUME_TEXTURE_MAX_SIZE = 128;
		protected const float	VOLUME_STACKS_UPSCALE = 4.0f;	// We render the stacks at N times the volume resolution so pixels are averaged together (smoother result)
		protected const float	VOLUME_SMOOTH_RADIUS = 0.0f;	// We can smooth the result a bit (SET TO 0 FOR RADIOSITY !)

		protected const bool	PREMULTIPLY_BY_ALPHA = false;	// True to pre-multiply diffuse and normal textures by alpha
																// Should be true if you intend to render the textures with slices or ray-marching
																// If you're using the result textures for the volume radiosity algorithm, this must be false

		// Space partitioning
		protected const int		MAX_PARTITIONS_COUNT = 32;
		protected const int		MIN_SLICES_COUNT_PER_PARTITION = 16;
		protected const int		MAX_SLICES_COUNT_PER_PARTITION = 64;

		protected const int		BOXES_COUNT = 100;
		protected const float	BOXES_SCATTER_RANGE = 40.0f;

		#endregion

		#region NESTED TYPES

		/// <summary>
		/// Represent the material for a box : a diffuse albedo texture and a normal texture
		/// The box also has a fixed WORLD size and a pivot point where it will be centered and rotated about
		/// </summary>
		[System.Diagnostics.DebuggerDisplay( "ID={ID} VoxelSize={m_VoxelSize}" )]
		protected class		BoxMaterial
		{
			#region FIELDS

			protected int			m_ID = 0;
			protected ITexture3D	m_DiffuseAlpha = null;		// The diffuse albedo texture
			protected ITexture3D	m_Normal = null;			// The normal texture
			protected float			m_VoxelSize = 0.0f;			// The size of a voxel in WORLD space
			protected Vector3		m_WorldSize = Vector3.Zero;	// The size of the entire volume in WORLD space
			protected Vector3		m_Pivot = Vector3.Zero;		// The texture's pivot

			protected static int	ms_MaterialID = -1;

			#endregion

			#region PROPERTIES

			public int			ID			{ get { return m_ID; } }
			public float		VoxelSize	{ get { return m_VoxelSize; } }
			public Vector3		WorldSize	{ get { return m_WorldSize; } }
			public Vector3		Pivot		{ get { return m_Pivot; } }

			#endregion

			#region METHODS

			public	BoxMaterial( ITexture3D _DiffuseAlpha, ITexture3D _Normal, float _VoxelSize, Vector3 _Pivot )
			{
				m_DiffuseAlpha = _DiffuseAlpha;
				m_Normal = _Normal;
				m_VoxelSize = _VoxelSize;
				m_WorldSize = m_VoxelSize * _DiffuseAlpha.Size3;
				m_Pivot = _Pivot;
				m_ID = ++ms_MaterialID;
			}

			public void		Apply( VariableResource _vDiffuseAlpha, VariableResource _vNormal, VariableVector _vSize, VariableVector _vInvSize )
			{
				_vDiffuseAlpha.SetResource( m_DiffuseAlpha );
				_vNormal.SetResource( m_Normal );
				_vSize.Set( m_DiffuseAlpha.Size3 );
				_vInvSize.Set( m_DiffuseAlpha.InvSize3 );
			}

			#endregion
		}

		/// <summary>
		/// Represents a box filled with a 3D texture
		/// The box can be oriented and placed anywhere in the WORLD
		/// </summary>
		[System.Diagnostics.DebuggerDisplay( "ID={ID} MatID={m_Material.ID}" )]
		protected class		Box
		{
			#region FIELDS

			protected Matrix		m_Box2World = Matrix.Identity;
			protected Matrix		m_World2UVW = Matrix.Identity;
			protected Matrix		m_Camera2UVW = Matrix.Identity;
			protected BoxMaterial	m_Material = null;
			protected int			m_ID = 0;

			protected Vector3[]		m_BBoxCorners = new Vector3[8];	// The bounding box's corners in WORLD space
			protected Vector4[]		m_BBoxCornersCamera = new Vector4[8];	// The bounding box's corners in CAMERA space
			protected float			m_ZMin = 0.0f;
			protected float			m_ZMax = 0.0f;
			protected Vector4		m_BBoxMinMaxXYCamera;

			protected static int	ms_CellID = -1;

			#endregion

			#region PROPERTIES

			public int			ID					{ get { return m_ID; } }
			public BoxMaterial	Material			{ get { return m_Material; } }
			public Matrix		Box2World			{ get { return m_Box2World; } private set { m_Box2World = value; UpdateBBox(); } }
			public Matrix		World2UVW			{ get { return m_World2UVW; } }
			public Matrix		Camera2UVW			{ get { return m_Camera2UVW; } }
			public Vector3[]	BBoxCorners			{ get { return m_BBoxCorners; } }
			public Vector4[]	BBoxCornersCamera	{ get { return m_BBoxCornersCamera; } }
			public Vector4		MinMaxXYCamera		{ get { return m_BBoxMinMaxXYCamera; } }
			public float		CameraZMin			{ get { return m_ZMin; } }
			public float		CameraZMax			{ get { return m_ZMax; } }

			#endregion

			#region METHODS

			public	Box( Vector3 _Position, Vector3 _RotationAxis, float _RotationAngle, BoxMaterial _Material )
			{
				m_Material = _Material;
				Set( _Position, _RotationAxis, _RotationAngle );
				m_ID = ++ms_CellID;
			}

			public void		Set( Vector3 _Position, Vector3 _RotationAxis, float _RotationAngle )
			{
				// Build the rotation matrix
				Matrix	Transform = Matrix.RotationAxis( _RotationAxis, _RotationAngle );

				// Compute pivot in WORLD space
				Vector3	PivotWorld = Vector3.TransformCoordinate( m_Material.Pivot, Transform );

				// Setup translation
				Transform.TranslationVector = _Position - PivotWorld;

				// Update
				Box2World = Transform;

				// Compute the WORLD => UVW transform
				Transform.Row1 *= m_Material.WorldSize.X;	// Scale by world size
				Transform.Row2 *= m_Material.WorldSize.Y;
				Transform.Row3 *= m_Material.WorldSize.Z;
				Transform.TranslationVector += 0.5f * (Vector3) (-Transform.Row1 + Transform.Row2 - Transform.Row3);	// Move center to top left back corner
				Transform.Row2 = -Transform.Row2;			// Negate Y axis (as V increases downard)
				Transform.Invert();							// Inverse UVW2World

				m_World2UVW = Transform;
			}

			/// <summary>
			/// Transforms the BBox corners into camera space and updates the ZMin/ZMax values
			/// </summary>
			/// <param name="_Camera"></param>
			/// 
			Vector3[]	m_Temp = new Vector3[8];
			public void		Transform( ref Matrix _Camera2World, ref Matrix _World2Camera )
			{
				// Transform BBox into camera space
				Vector3.TransformCoordinate( m_BBoxCorners, ref _World2Camera, m_Temp );

				// Find min/max
				m_ZMin = +float.MaxValue;
				m_ZMax = -float.MaxValue;
				m_BBoxMinMaxXYCamera = new Vector4( +float.MaxValue, +float.MaxValue, -float.MaxValue, -float.MaxValue );
				for ( int CornerIndex=0; CornerIndex < 8; CornerIndex++ )
				{
					float	Z;
					m_BBoxCornersCamera[CornerIndex].X = m_Temp[CornerIndex].X;
					m_BBoxCornersCamera[CornerIndex].Y = m_Temp[CornerIndex].Y;
					m_BBoxCornersCamera[CornerIndex].Z = Z = m_Temp[CornerIndex].Z;
					m_BBoxCornersCamera[CornerIndex].W = 1.0f;
					m_ZMin = Math.Min( m_ZMin, Z );
					m_ZMax = Math.Max( m_ZMax, Z );

					m_BBoxMinMaxXYCamera.X = Math.Min( m_BBoxMinMaxXYCamera.X, m_Temp[CornerIndex].X );
					m_BBoxMinMaxXYCamera.Y = Math.Min( m_BBoxMinMaxXYCamera.Y, m_Temp[CornerIndex].Y );
					m_BBoxMinMaxXYCamera.Z = Math.Max( m_BBoxMinMaxXYCamera.Z, m_Temp[CornerIndex].X );
					m_BBoxMinMaxXYCamera.W = Math.Max( m_BBoxMinMaxXYCamera.W, m_Temp[CornerIndex].Y );
				}

				m_Camera2UVW = _Camera2World * m_World2UVW;
			}

			protected void	UpdateBBox()
			{
				// Build BBox in LOCAL space
				BoundingBox	BBox = new BoundingBox( -0.5f * m_Material.WorldSize, +0.5f * m_Material.WorldSize );

				// Transform its corners into WORLD space
				Vector3.TransformCoordinate( BBox.GetCorners(), ref m_Box2World, m_BBoxCorners );
			}

			#endregion
		}

		/// <summary>
		/// A partition cuts the space with planes orthogonal to view direction
		/// 
		/// A partition will contain a set of boxes to render, each of these boxes will be
		///  sliced with a given amount of slices that will depend on the distance of the partition
		///  to the camera.
		/// 
		/// Therefore, it's really important to correctly choose the size of partitions and the
		///  amount of slices they are composed of as it will strongly impact the visual quality
		/// </summary>
		[System.Diagnostics.DebuggerDisplay( "Zmin={m_ZMin} Zmax={m_ZMax} Slices={m_SlicesCount} Boxes={m_CurrentBoxes.Count}" )]
		protected class		Partition : IDisposable, IComparer<Box>
		{
			#region FIELDS

			protected float		m_ZMin = 0.0f;
			protected float		m_ZMax = 0.0f;
			protected int		m_SlicesCount = 0;
			protected List<Box>	m_CurrentBoxes = new List<Box>();
			protected VertexBuffer<VS_T2>	m_VB = null;

			#endregion

			#region PROPERTIES

			public float		ZMin		{ get { return m_ZMin; } }
			public float		ZMax		{ get { return m_ZMax; } }
			public int			SlicesCount	{ get { return m_SlicesCount; } }
			public int			BoxesCount	{ get { return m_CurrentBoxes.Count; } }

			#endregion

			#region METHODS

			/// <param name="_Device"></param>
			/// <param name="_ZStart">The depth at which the partition starts</param>
			/// <param name="_MinPartitionSize">The minimum size before ending this partition</param>
			/// <param name="_MinSlicesCount">The minimum amount of slices befor ending this partition</param>
			/// <param name="_MaxSlicesCount">The maximum amount of slices befor ending this partition</param>
			/// <param name="_PixelSize">The size of a pixel at Z=1 (i.e. tan(FOV/2) / (SceenHeight/2))</param>
			/// <param name="_AverageVoxelSize">The average size of the voxels in WORLD space</param>
			public	Partition( Nuaj.Device _Device, float _ZStart, float _MinPartitionSize, int _MinSlicesCount, int _MaxSlicesCount, float _PixelSize, float _AverageVoxelSize )
			{
				List<VS_T2>	Slices = new List<VS_T2>();
				VS_T2		V = new VS_T2();

				m_ZMin = _ZStart;

				float	Z = m_ZMin;
				while ( ((Z-m_ZMin) < _MinPartitionSize || Slices.Count < _MinSlicesCount) && Slices.Count < _MaxSlicesCount )
				{
					// Compute mip level at current distance
					float	PixelSizeAtZ = _PixelSize * Z;								// This is the size of pixel projected at the current Z
							PixelSizeAtZ = Math.Max( _AverageVoxelSize, PixelSizeAtZ );	// Can't be lower than the voxel size
					float	VoxelSizeRatio = PixelSizeAtZ / _AverageVoxelSize;			// This is the ratio of pixel size / voxel size
					float	MipLevel = (float) (Math.Log( VoxelSizeRatio ) / Math.Log( 2.0 ));	// The log2 of that ratio is our mip level

					// Add a new slice
					V.UV.X = Z;
					V.UV.Y = MipLevel;
					Slices.Add( V );

					// Increase Z by the pixel size
					Z += PixelSizeAtZ;
				}
				m_ZMax = Z;
#if !USE_ALPHA2COVERAGE
				Slices.Reverse();	// Back to front !
#endif
				m_VB = new VertexBuffer<VS_T2>( _Device, "PartitionVB", Slices.ToArray() );
				m_SlicesCount = Slices.Count;
			}

			public void	BeginAddBoxes()
			{
				m_CurrentBoxes.Clear();
			}

			public void	AddBox( Box _Box )
			{
				m_CurrentBoxes.Add( _Box );
			}

			public void	EndAddBoxes()
			{
				m_CurrentBoxes.Sort( this );	// Sort by material ID
			}

			public void	Render( EffectPass _Pass, VariableVector _BBoxCorners, VariableVector _BBoxMinMax, VariableMatrix _Camera2UVW, VariableResource _vDiffuseAlpha, VariableResource _vNormal, VariableVector _vSize, VariableVector _vInvSize )
			{
				if ( m_CurrentBoxes.Count == 0 )
					return;	// Empty partition...

#if DRAW_SLICE_BY_SLICE
				// Draw slice by slice, starting from the farthest
				m_VB.Use();
				int	PreviousMatID = -1;
				for ( int SliceIndex=0; SliceIndex < m_SlicesCount; SliceIndex++ )
				{
					// Draw all boxes
					foreach ( Box B in m_CurrentBoxes )
					{
						int	CurrentMatID = B.Material.ID;
						if ( CurrentMatID != PreviousMatID )
						{	// Apply new material
							B.Material.Apply( _vDiffuseAlpha, _vNormal, _vSize, _vInvSize );
							PreviousMatID = CurrentMatID;
						}

						// Upload BBox infos
#if SLICE_BOXES
						_BBoxCorners.Set( B.BBoxCornersCamera );
#else
						_BBoxMinMax.Set( B.MinMaxXYCamera );
						_Camera2UVW.SetMatrix( B.Camera2UVW );
#endif
						_Pass.Apply();

						// Draw a single slice
						m_VB.Draw( SliceIndex, 1 );
					}
				}
#else
				// Draw box by box with depth testing and writing enabled
				m_VB.Use();
				int	PreviousMatID = -1;
				foreach ( Box B in m_CurrentBoxes )
				{
					int	CurrentMatID = B.Material.ID;
					if ( CurrentMatID != PreviousMatID )
					{	// Apply new material
						B.Material.Apply( _vDiffuseAlpha, _vNormal, _vSize, _vInvSize );
						PreviousMatID = CurrentMatID;
					}

					// Upload BBox infos
#if SLICE_BOXES
					_BBoxCorners.Set( B.BBoxCornersCamera );
#else
					_BBoxMinMax.Set( B.MinMaxXYCamera );
					_Camera2UVW.SetMatrix( B.Camera2UVW );
#endif
					_Pass.Apply();

					// Draw all slices at once
					m_VB.Draw();
				}
#endif
			}

			#region IDisposable Members

			public void Dispose()
			{
				m_VB.Dispose();
				m_VB = null;
			}

			#endregion

			#region IComparer<Box> Members

			// This compares by material ID first then box ID
			public int Compare( Box x, Box y )
			{
				int	IDx = x.Material.ID << 24 | (x.ID & 0xFFFFFF);
				int	IDy = y.Material.ID << 24 | (y.ID & 0xFFFFFF);
				return IDx < IDy ? -1 : (IDx > IDy ? +1 : 0);
			}

			#endregion

			#endregion
		}

		protected class		MeshPrimitiveBuilder : MeshPrimitiveBuilderBase<VS_P3N3G3T2>
		{
			#region METHODS

			public MeshPrimitiveBuilder()
			{
				// Build signature
				m_VertexSignature.AddField( "Position", VERTEX_FIELD_USAGE.POSITION, VERTEX_FIELD_TYPE.FLOAT3, 0 );
				m_VertexSignature.AddField( "Normal", VERTEX_FIELD_USAGE.NORMAL, VERTEX_FIELD_TYPE.FLOAT3, 0 );
				m_VertexSignature.AddField( "Tangent", VERTEX_FIELD_USAGE.TANGENT, VERTEX_FIELD_TYPE.FLOAT3, 0 );
				m_VertexSignature.AddField( "UV", VERTEX_FIELD_USAGE.TEX_COORD2D, VERTEX_FIELD_TYPE.FLOAT2, 0 );

				// Build the vertices and indices
				VS_P3N3G3T2	V;
				V.Normal = new Vector3( 0.0f, 1.0f, 1.0f );
				V.Normal.Normalize();
				V.Tangent = new Vector3( 1.0f, 0.0f, 0.0f );
				V.Tangent.Normalize();

				V.Position = new Vector3( -2.0f, -2.0f, +2.0f );
				V.UV = new Vector2( 0.0f, 0.0f );
				m_Vertices.Add( V );

				V.Position = new Vector3( +2.0f, -2.0f, +2.0f );
				V.UV = new Vector2( 1.0f, 0.0f );
				m_Vertices.Add( V );

				V.Position = new Vector3( 0.0f, +2.0f, -2.0f );
				V.UV = new Vector2( 0.5f, 1.0f );
				m_Vertices.Add( V );

				m_Indices.AddRange( new int[] { 0, 1, 2 } );
			}

			public override object GetField( int _VertexIndex, int _FieldIndex )
			{
				switch ( _FieldIndex )
				{
					case 0: return m_Vertices[_VertexIndex].Position;
					case 1: return m_Vertices[_VertexIndex].Normal;
					case 2: return m_Vertices[_VertexIndex].Tangent;
					case 3: return m_Vertices[_VertexIndex].UV;
				}

				return null;
			}

			#endregion
		}

		#endregion

		#region FIELDS

		protected Nuaj.Device					m_Device = null;

		//////////////////////////////////////////////////////////////////////////
		// Scene and renderer
		protected SceneTextureProvider			m_TextureProvider = null;
		protected Scene							m_Scene = null;

		protected Renderer						m_Renderer = null;
		protected RenderTechniqueScene			m_RenderScene = null;

		protected Camera 						m_Camera = null;
		protected Nuaj.Helpers.CameraManipulator	m_CamManipulator = null;

		//////////////////////////////////////////////////////////////////////////
		// Materials
#if DISPLAY_WITH_RAY_MARCHING
		Material<VS_Pt4>						m_MaterialRenderVolumeMesh = null;
#else
		Material<VS_T2>							m_MaterialRenderVolumeMesh = null;
#endif

		//////////////////////////////////////////////////////////////////////////
		// Adaptative slicing data
		protected List<BoxMaterial>				m_BoxMaterials = new List<BoxMaterial>();
		protected List<Box>						m_TotalBoxes = new List<Box>();
		protected List<Box>						m_CurrentBoxes = new List<Box>();
		protected List<Partition>				m_Partitions = new List<Partition>();


		//////////////////////////////////////////////////////////////////////////
		// Textures
		protected RenderTarget3D<PF_RGBA16F>	m_DiffuseAlpha = null;
		protected RenderTarget3D<PF_RGBA16F>	m_Normal = null;
		protected RenderTarget3D<PF_RGBA16F>	m_DistanceField = null;

		//////////////////////////////////////////////////////////////////////////
		// Primitives
		Nuaj.Helpers.ScreenQuad					m_Quad = null;

		protected Nuaj.Cirrus.Utility.ProfilerForm	m_Profiler = null;

		// Dispose stack
		protected Stack<IDisposable>			m_Disposables = new Stack<IDisposable>();

		#endregion

		#region METHODS

		public VolumeMeshForm()
		{
			InitializeComponent();

			BuildGSCode();

			//////////////////////////////////////////////////////////////////////////
			// Create the device
			try
			{
				SwapChainDescription	Desc = new SwapChainDescription()
				{
					BufferCount = 1,
					ModeDescription = new ModeDescription( panelOutput.Width, panelOutput.Height, new Rational(60, 1), Format.R8G8B8A8_UNorm ),
					IsWindowed = true,
					SampleDescription = new SampleDescription( 1, 0 ),
					SwapEffect = SwapEffect.Discard,
					Usage = Usage.RenderTargetOutput
				};

				m_Device = ToDispose( Nuaj.Device.CreateInstance( Desc, panelOutput, false ) );
			}
			catch ( Exception _e )
			{
				throw new Exception( "Failed to create the DirectX device !", _e );
			}

			//////////////////////////////////////////////////////////////////////////
			// Create the render material
#if DISPLAY_WITH_RAY_MARCHING
			m_MaterialRenderVolumeMesh = ToDispose( new Material<VS_Pt4>( m_Device, "Render Volume Mesh Material", ShaderModel.SM4_0, new System.IO.FileInfo( "./FX/VolumeMeshBuilder/RenderVolumeMeshRayMarching.fx" ) ) );
#else
			m_MaterialRenderVolumeMesh = ToDispose( new Material<VS_T2>( m_Device, "Render Volume Mesh Material", ShaderModel.SM4_0, new System.IO.FileInfo( "./FX/VolumeMeshBuilder/RenderVolumeMeshSlices.fx" ) ) );
#endif

			//////////////////////////////////////////////////////////////////////////
			// Build the main camera
			m_Camera = ToDispose( new Camera( m_Device, "Main Camera" ) );
			m_Camera.CreatePerspectiveCamera( 90.0f * (float) Math.PI / 180.0f, (float) Width / Height, 0.01f, 1000.0f );
			m_Camera.Activate();

			m_CamManipulator = new Nuaj.Helpers.CameraManipulator();
			m_CamManipulator.Attach( panelOutput, m_Camera );
			m_CamManipulator.InitializeCamera( new Vector3( 0.0f, 4.0f, 10.0f ), new Vector3( 0.0f, 1.0f, 0.0f ), Vector3.UnitY );

			m_Quad = ToDispose( new Nuaj.Helpers.ScreenQuad( m_Device, "Quad" ) );

#if !LOAD_3D_TEXTURES

			//////////////////////////////////////////////////////////////////////////
			// Create the renderer & its pipelines
			m_Renderer = ToDispose( new Renderer( m_Device, "Renderer" ) );

			Pipeline	Main = ToDispose( new Pipeline( m_Device, "MainPipeline", Pipeline.TYPE.MAIN_RENDERING ) );
			m_Renderer.AddPipeline( Main );


			//////////////////////////////////////////////////////////////////////////
			// Add the Scene Renderer
			m_RenderScene = ToDispose( new RenderTechniqueScene( m_Device, "Scene Renderer" ) );
			m_RenderScene.Scene = m_Scene;

			Main.AddTechnique( m_RenderScene );

			//////////////////////////////////////////////////////////////////////////
			// Load the FBX scene
			m_Scene = ToDispose( new Scene( m_Device, "Scene", m_Renderer ) );

#if false
			// Build scene manually
			Scene.Node	Root = m_Scene.CreateNode( "Root", null, Matrix.Identity );
			Scene.Mesh	M = m_Scene.CreateMesh( "Pipo", Root, Matrix.Identity );
						M.BBox = new BoundingBox( -2.0f * Vector3.One, +2.0f * Vector3.One );

			MeshPrimitiveBuilder		Builder = new MeshPrimitiveBuilder();	// This builds a simple triangle

			// This is a simple material, no texture, only a diffuse white color
			Scene.MaterialParameters	MatParams = m_Scene.CreateMaterialParameters( "PipoMaterial", "Phong" );
			MatParams.CreateParameter( "HasDiffuseTexture", Scene.MaterialParameters.PARAMETER_TYPE.BOOL ).AsBool.Value = false;
			MatParams.CreateParameter( "DiffuseColor", Scene.MaterialParameters.PARAMETER_TYPE.FLOAT4 ).AsFloat4.Value = new Vector4( 1.0f, 0.5f, 0.25f, 1.0f );
			MatParams.CreateParameter( "HasNormalTexture", Scene.MaterialParameters.PARAMETER_TYPE.BOOL ).AsBool.Value = false;

			// Build the actual primitive
			M.AddPrimitive( Builder.BuildPrimitive( m_RenderScene, M, "Simple Triangle", MatParams ) );

			// Propagate state once so everything is up to date
			Root.PropagateState();
#else
			// Load from FBX
// 			string	TexturesDirectory = "./Meshes/Trees/Frecle/";
// 			string	SceneDirectory = "./Meshes/Trees/SpeedTree/SpeedTree_Widescreen/_spt_l08/";
// 			string	SceneName = "l08_sosna_01.fbx";
// 			string	TexturesDirectory = "./Meshes/Trees/Frecle/";
// 			string	SceneDirectory = "./Meshes/Trees/Frecle/";
// 			string	SceneName = "Test_Teapot.fbx";

				// Sponza
			string	TexturesDirectory = "./Meshes/Sponza/";
			string	SceneDirectory = "./Meshes/Sponza/";
			string	SceneName = "Sponza_RedCeiling.fbx";

			m_TextureProvider = ToDispose( new SceneTextureProvider( m_Device, "", new System.IO.DirectoryInfo( TexturesDirectory ) ) );
			m_TextureProvider.ForceCreateMipMaps = true;

			MaterialMap	MMap = new MaterialMap();
			MMap.RegisterMapper( ( Scene.MaterialParameters _MaterialParameters ) =>
			{
				return m_RenderScene;
			} );

			using ( SceneLoader SceneLoader = new SceneLoader( m_Device, "SceneLoader" ) )
			{
				SceneLoader.Load( new System.IO.FileInfo( SceneDirectory + SceneName ), m_Scene, MMap, m_TextureProvider );
			}
#endif

			//////////////////////////////////////////////////////////////////////////
			// Perform mesh rendering into the 3D texture
			float		VoxelSize;
			BoundingBox	SceneBBox;
			RenderVolumeMesh( VOLUME_TEXTURE_MAX_SIZE, VOLUME_STACKS_UPSCALE, 0.1f, VOLUME_SMOOTH_RADIUS, PREMULTIPLY_BY_ALPHA, out SceneBBox, out VoxelSize, out m_DiffuseAlpha, out m_Normal, out m_DistanceField );

			ToDispose( m_DiffuseAlpha );
			ToDispose( m_Normal );
			ToDispose( m_DistanceField );

			// Save textures
			System.IO.FileInfo	File = new System.IO.FileInfo( "./Media/3DTextures/Sponza/Sponza_Diffuse.tex3" );
			using ( System.IO.Stream S = File.Create() )
				m_DiffuseAlpha.Save( S );

			File = new System.IO.FileInfo( "./Media/3DTextures/Sponza/Sponza_Normal.tex3" );
			using ( System.IO.Stream S = File.Create() )
				m_Normal.Save( S );

			File = new System.IO.FileInfo( "./Media/3DTextures/Sponza/Sponza_Distance.tex3" );
			using ( System.IO.Stream S = File.Create() )
				m_DistanceField.Save( S );

			File = new System.IO.FileInfo( "./Media/3DTextures/Sponza/Sponza_TexParams.infos" );
			using ( System.IO.Stream S = File.Create() )
				WriteTexParams( S, m_DiffuseAlpha, VoxelSize, SceneBBox );

			File = new System.IO.FileInfo( "./Media/3DTextures/Sponza/Sponza_TexParams.cs" );
			using ( System.IO.StreamWriter W = File.CreateText() )
				WriteTexParamsTEXT( W, m_DiffuseAlpha, VoxelSize, SceneBBox );

#else
			System.IO.FileInfo	File = new System.IO.FileInfo( "./Media/3DTextures/Sponza/Sponza_Diffuse.tex3" );
			using ( System.IO.Stream S = File.OpenRead() )
				m_DiffuseAlpha = ToDispose( RenderTarget3D<PF_RGBA16F>.CreateFromStream( m_Device, "Diffuse+Alpha", S ) );

			File = new System.IO.FileInfo( "./Media/3DTextures/Sponza/Sponza_Normal.tex3" );
			using ( System.IO.Stream S = File.OpenRead() )
				m_Normal = ToDispose( RenderTarget3D<PF_RGBA16F>.CreateFromStream( m_Device, "Normal", S ) );

			File = new System.IO.FileInfo( "./Media/3DTextures/Sponza/Sponza_Distance.tex3" );
			using ( System.IO.Stream S = File.OpenRead() )
				m_DistanceField = ToDispose( RenderTarget3D<PF_RGBA16F>.CreateFromStream( m_Device, "DistanceField", S ) );

			// We need to setup the voxel size ourselves here...
			float	VoxelSize = 0.05561427f;	// Teapot
#endif

			//////////////////////////////////////////////////////////////////////////
			// Create a single material and several randomly placed boxes
			Vector3	WorldSize = VoxelSize * m_DiffuseAlpha.Size3;
			BoxMaterial	Mat = new BoxMaterial( m_DiffuseAlpha, m_Normal, VoxelSize, new Vector3( 0.0f, -0.5f * WorldSize.Y, 0.0f ) );
			m_BoxMaterials.Add( Mat );

#if true	// Use plenty of boxes
			Random	RNG = new Random( 1 );
			for ( int BoxIndex=0; BoxIndex < BOXES_COUNT; BoxIndex++ )
			{
				Box	B = new Box( BOXES_SCATTER_RANGE * new Vector3( 0.5f * (2.0f * (float) RNG.NextDouble() - 1.0f), 0.0f, -(float) RNG.NextDouble() ), Vector3.UnitY, (float) (2.0 * Math.PI * RNG.NextDouble()), Mat );
				m_TotalBoxes.Add( B );
			}
#else
			m_TotalBoxes.Add( new Box( Vector3.Zero, Vector3.UnitY, 0.0f, Mat ) );
#endif
			integerTrackbarControlBoxesCount.RangeMax =
			integerTrackbarControlBoxesCount.VisibleRangeMax = m_TotalBoxes.Count;
			integerTrackbarControlBoxesCount.Value = 1;	// Start with only 1 !

			//////////////////////////////////////////////////////////////////////////
			// Initialize space partitioning
			float	AverageVoxelSize = VoxelSize;
			float	PixelSize = (float) Math.Tan( 0.5 * m_Camera.PerspectiveFOV ) / (0.5f * panelOutput.Height);
			float	MinPartitionSize = VoxelSize * m_DiffuseAlpha.Size3.Length();	// The size of the volume's diagonal in WORLD space

			float	PartitionZ = m_Camera.Near;	// We start at ZNear
			int		SumSlices = 0;
			for ( int PartitionIndex=0; PartitionIndex < MAX_PARTITIONS_COUNT; PartitionIndex++ )
			{
				Partition	P = ToDispose( new Partition( m_Device, PartitionZ, MinPartitionSize, MIN_SLICES_COUNT_PER_PARTITION, MAX_SLICES_COUNT_PER_PARTITION, PixelSize, AverageVoxelSize ) );
				m_Partitions.Add( P );
				PartitionZ = P.ZMax;
				SumSlices += P.SlicesCount;
			}
#if !USE_ALPHA2COVERAGE
			m_Partitions.Reverse();	// Back to front order !
#endif

			//////////////////////////////////////////////////////////////////////////
			// Create the profiler
			m_Profiler = new Nuaj.Cirrus.Utility.ProfilerForm( m_Device );
		}

		protected override void OnClosing( CancelEventArgs e )
		{
			while( m_Disposables.Count > 0 )
				m_Disposables.Pop().Dispose();

			base.OnClosing( e );
		}

		/// <summary>
		/// We'll keep you busy !
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="e"></param>
		public void	RunMessageLoop()
		{
			//////////////////////////////////////////////////////////////////////////
			// Start the render loop
			string		OriginalText = Text;
			DateTime	StartTime = DateTime.Now;
			DateTime	LastFrameTime = DateTime.Now;
			DateTime	LastFPSTime = DateTime.Now;
			int			FPSFramesCount = 0;

			SharpDX.Windows.MessagePump.Run( this, () =>
			{
				// Update time
				DateTime	CurrentFrameTime = DateTime.Now;				
				float	fDeltaTime = (float) (CurrentFrameTime - LastFrameTime).TotalSeconds;
				float	fTotalTime = (float) (CurrentFrameTime - StartTime).TotalSeconds;
				LastFrameTime = CurrentFrameTime;

				m_Device.StartProfiling( m_Profiler.FlushEveryOnTask );
				m_Device.AddProfileTask( null, "Rendering", "START" );

				// =============== Render Scene ===============
				// Draw
				m_Device.SetDefaultRenderTarget();
				m_Device.ClearRenderTarget( m_Device.DefaultRenderTarget, Vector4.Zero );
//				m_Device.ClearRenderTarget( m_Device.DefaultRenderTarget, new Color4( System.Drawing.Color.CornflowerBlue.ToArgb() ) );
				m_Device.ClearDepthStencil( m_Device.DefaultDepthStencil, DepthStencilClearFlags.Depth, 1.0f, 0 );


				using ( m_MaterialRenderVolumeMesh.UseLock() )
				{
#if DISPLAY_WITH_RAY_MARCHING

#if false	// Use stoopid slices (DEBUG)
					m_Device.SetStockRasterizerState( Nuaj.Device.HELPER_STATES.NO_CULLING );
					m_Device.SetStockDepthStencilState( Nuaj.Device.HELPER_DEPTH_STATES.DISABLED );
					m_Device.SetStockBlendState( Nuaj.Device.HELPER_BLEND_STATES.ADDITIVE );	// use this to debug distance field
//					m_Device.SetStockBlendState( Nuaj.Device.HELPER_BLEND_STATES.BLEND );		// use this to debug diffuse/normal slices

					m_MaterialRenderVolumeMesh.CurrentTechnique = m_MaterialRenderVolumeMesh.GetTechniqueByName( "RenderVolumeMesh_Slices" );

					m_MaterialRenderVolumeMesh.GetVariableByName( "BufferInvSize" ).AsVector.Set( m_Device.DefaultRenderTarget.InvSize3 );

					m_MaterialRenderVolumeMesh.GetVariableByName( "DiffuseField" ).AsResource.SetResource( m_DiffuseAlpha );
					m_MaterialRenderVolumeMesh.GetVariableByName( "NormalField" ).AsResource.SetResource( m_Normal );
					m_MaterialRenderVolumeMesh.GetVariableByName( "DistanceField" ).AsResource.SetResource( m_DistanceField );

#if DEBUG_SLICES
					m_MaterialRenderVolumeMesh.GetVariableByName( "VolumeSize" ).AsVector.Set( 1.1f * m_BoxMaterials[0].VoxelSize * new Vector3( m_StackDiffuse.Width, m_StackDiffuse.Height, m_StackDiffuse.ArraySize ) );
					m_MaterialRenderVolumeMesh.GetVariableByName( "TextureSize" ).AsVector.Set( new Vector3( m_StackDiffuse.Width, m_StackDiffuse.Height, m_StackDiffuse.ArraySize ) );
					m_MaterialRenderVolumeMesh.GetVariableByName( "DebugSlicesCount" ).AsScalar.Set( m_StackDiffuse.ArraySize );
					m_MaterialRenderVolumeMesh.GetVariableByName( "DebugStack" ).AsResource.SetResource( m_StackDiffuse );
					m_MaterialRenderVolumeMesh.GetVariableByName( "DebugStackNormal" ).AsResource.SetResource( m_StackNormal );
					m_MaterialRenderVolumeMesh.ApplyPass( 0 );
					m_Quad.RenderInstanced( 0, m_StackDiffuse.ArraySize );
#else
					m_MaterialRenderVolumeMesh.GetVariableByName( "VolumeSize" ).AsVector.Set( 1.1f * m_BoxMaterials[0].VoxelSize * new Vector3( m_DiffuseAlpha.Width, m_DiffuseAlpha.Height, m_DiffuseAlpha.Depth ) );
					m_MaterialRenderVolumeMesh.GetVariableByName( "TextureSize" ).AsVector.Set( new Vector3( m_DiffuseAlpha.Width, m_DiffuseAlpha.Height, m_DiffuseAlpha.Depth ) );
					m_MaterialRenderVolumeMesh.ApplyPass( 0 );
					m_Quad.RenderInstanced( 0, m_DiffuseAlpha.Depth );
#endif

#else				// Use ray-marching with distance field
					m_Device.SetStockRasterizerState( Nuaj.Device.HELPER_STATES.NO_CULLING );
					m_Device.SetStockDepthStencilState( Nuaj.Device.HELPER_DEPTH_STATES.DISABLED );
					m_Device.SetStockBlendState( Nuaj.Device.HELPER_BLEND_STATES.DISABLED );

					m_MaterialRenderVolumeMesh.GetVariableByName( "BufferInvSize" ).AsVector.Set( m_Device.DefaultRenderTarget.InvSize3 );

					m_MaterialRenderVolumeMesh.GetVariableByName( "VolumeSize" ).AsVector.Set( m_DiffuseAlpha.Size3 );
					m_MaterialRenderVolumeMesh.GetVariableByName( "VolumeInvSize" ).AsVector.Set( m_DiffuseAlpha.InvSize3 );
					m_MaterialRenderVolumeMesh.GetVariableByName( "VoxelSize" ).AsScalar.Set( m_BoxMaterials[0].VoxelSize );
					m_MaterialRenderVolumeMesh.GetVariableByName( "VoxelInvSize" ).AsScalar.Set( 1.0f / m_BoxMaterials[0].VoxelSize );

					m_MaterialRenderVolumeMesh.GetVariableByName( "PreMultiplyByAlpha" ).AsScalar.Set( PREMULTIPLY_BY_ALPHA );

					m_MaterialRenderVolumeMesh.GetVariableByName( "DiffuseField" ).AsResource.SetResource( m_DiffuseAlpha );
					m_MaterialRenderVolumeMesh.GetVariableByName( "NormalField" ).AsResource.SetResource( m_Normal );
					m_MaterialRenderVolumeMesh.GetVariableByName( "DistanceField" ).AsResource.SetResource( m_DistanceField );

					m_MaterialRenderVolumeMesh.ApplyPass( 0 );
					m_Quad.Render();
#endif

#else
					m_Device.SetStockRasterizerState( Nuaj.Device.HELPER_STATES.NO_CULLING );
#if DRAW_SLICE_BY_SLICE
					m_Device.SetStockDepthStencilState( Nuaj.Device.HELPER_DEPTH_STATES.DISABLED );
#else
					m_Device.SetStockDepthStencilState( Nuaj.Device.HELPER_DEPTH_STATES.WRITE_CLOSEST_OR_EQUAL );
#endif

#if !USE_ALPHA2COVERAGE
					m_Device.SetStockBlendState( Nuaj.Device.HELPER_BLEND_STATES.BLEND );
#else
					m_Device.SetStockBlendState( Nuaj.Device.HELPER_BLEND_STATES.ALPHA2COVERAGE );
#endif

#if !SLICE_BOXES
					m_MaterialRenderVolumeMesh.CurrentTechnique = m_MaterialRenderVolumeMesh.GetTechniqueByName( "RenderVolumeMesh_NoSlicing" );
#endif
					EffectPass			Pass = m_MaterialRenderVolumeMesh.CurrentTechnique.GetPassByIndex( 0 );
					VariableVector		vBBoxCorners = m_MaterialRenderVolumeMesh.GetVariableByName( "BBox" ).AsVector;
					VariableVector		vBBoxMinMax = m_MaterialRenderVolumeMesh.GetVariableByName( "BBoxMinMax" ).AsVector;
					VariableMatrix		vCamera2BBoxUVW = m_MaterialRenderVolumeMesh.GetVariableByName( "Camera2BBoxUVW" ).AsMatrix;
					VariableVector		vTextureSize = m_MaterialRenderVolumeMesh.GetVariableByName( "VolumeSize" ).AsVector;
					VariableVector		vTextureInvSize = m_MaterialRenderVolumeMesh.GetVariableByName( "VolumeInvSize" ).AsVector;
					VariableResource	vDiffuseAlpha = m_MaterialRenderVolumeMesh.GetVariableByName( "DiffuseAlpha" ).AsResource;
					VariableResource	vNormal = m_MaterialRenderVolumeMesh.GetVariableByName( "Normal" ).AsResource;

					m_MaterialRenderVolumeMesh.GetVariableByName( "PreMultiplyByAlpha" ).AsScalar.Set( PREMULTIPLY_BY_ALPHA );

					// Transform and sort boxes in their partitions
					m_Device.AddProfileTask( null, "Boxes", "Sort" );
					SortBoxes();

					// Render each partition
					m_Device.AddProfileTask( null, "Partition", "START" );

					m_Device.InputAssembler.SetPrimitiveTopology( SharpDX.Direct3D.PrimitiveTopology.PointList );
					int	PartitionIndex = 0;
					foreach ( Partition P in m_Partitions )
					{
						m_Device.AddProfileTask( null, "Partition" + PartitionIndex++ + " (" + P.SlicesCount + ") m" + P.ZMin.ToString( "G3" ) + " M" + P.ZMax.ToString( "G3" ), "Render " + P.BoxesCount + " Boxes" );
						P.Render( Pass, vBBoxCorners, vBBoxMinMax, vCamera2BBoxUVW, vDiffuseAlpha, vNormal, vTextureSize, vTextureInvSize );
					}

					m_Device.AddProfileTask( null, "Partition", "END" );
#endif
				}	// using ( m_MaterialRenderVolumeMesh )

				// Show !
				m_Device.Present();

				m_Device.AddProfileTask( null, "Rendering", "END" );
				m_Device.EndProfiling();

				// Update FPS
				FPSFramesCount++;
				DateTime	Now = DateTime.Now;
				double		DeltaMilliseconds = (Now - LastFPSTime).TotalMilliseconds;
				if ( DeltaMilliseconds > 1000 )
				{
					float	FPS = (float) (1000.0 * FPSFramesCount / DeltaMilliseconds);
					LastFPSTime = Now;
					FPSFramesCount = 0;
					Text = OriginalText + " - " + FPS.ToString( "G4" ) + " FPS";

					// Update partitions text
					string[]	Lines = new string[m_Partitions.Count];
					for ( int PartitionIndex=0; PartitionIndex < m_Partitions.Count; PartitionIndex++ )
					{
						Partition	P = m_Partitions[PartitionIndex];
						Lines[PartitionIndex] = "Partition #" + PartitionIndex + " (" + P.SlicesCount + ") [" + P.ZMin.ToString("G4") + "," + P.ZMax.ToString("G4") + "] => " + P.BoxesCount;
					}
					textBoxInfos.Lines = Lines;
				}
			} );
		}

		protected T	ToDispose<T>( T _Item ) where T : IDisposable
		{
			IDisposable	I = _Item as IDisposable;
			if ( I != null )
				m_Disposables.Push( I );

			return _Item;
		}

		/// <summary>
		/// Sorts each box in its partition(s)
		/// </summary>
		protected void	SortBoxes()
		{
			// 1] Transform boxes in CAMERA space
			Matrix	Camera2World = m_Camera.Camera2World;
			Matrix	World2Camera = m_Camera.World2Camera;
			foreach ( Box B in m_CurrentBoxes )
				B.Transform( ref Camera2World, ref World2Camera );

			// 2] Add boxes to each partition
			foreach ( Partition P in m_Partitions )
			{
				P.BeginAddBoxes();
				foreach ( Box B in m_CurrentBoxes )
					if ( B.CameraZMin <= P.ZMax && B.CameraZMax >= P.ZMin )
						P.AddBox( B );
				P.EndAddBoxes();
			}
		}

		#region Volume Mesh Building

#if DEBUG_SLICES
RenderTarget<PF_RGBA16F>	m_StackDiffuse = null;
RenderTarget<PF_RGBA16F>	m_StackNormal = null;
#endif

		/// <summary>
		/// Renders the primitives contained in the scene into a 3D texture
		/// </summary>
		/// <param name="_VolumeMaxSize">The size of the volume along its largest dimension</param>
		/// <param name="_StacksUpscale">The upscale factor to render the stacks in a more defined buffer (smoother result)</param>
		/// <param name="_SceneOffset">The offset to add to the scene's bounding box to center the scene safely inside the volume (default is 0)</param>
		/// <param name="_SmoothRadius">The smoothing radius in [0,1] that allows to smooth out the resulting textures</param>
		/// <param name="_bPreMultiplyByAlpha">True to pre-multiply diffuse and normal by alpha</param>
		/// <param name="_SceneBBox">Returns the scene's bounding-box</param>
		/// <param name="_VoxelSize">The size of a voxel in WORLD space</param>
		/// <param name="_DiffuseAlpha">The resulting Diffuse+Alpha 3D texture</param>
		/// <param name="_Normal">The resulting Normal 3D texture</param>
		/// <param name="_DistanceField">The resulting Distance 3D texture</param>
		protected void	RenderVolumeMesh( int _VolumeMaxSize, float _StacksUpscale, float _SceneOffset, float _SmoothRadius, bool _bPreMultiplyByAlpha, out BoundingBox _SceneBBox, out float _VoxelSize, out RenderTarget3D<PF_RGBA16F> _DiffuseAlpha, out RenderTarget3D<PF_RGBA16F> _Normal, out RenderTarget3D<PF_RGBA16F> _DistanceField )
		{
			if ( _StacksUpscale < 1.0f )
				throw new Exception( "The StacksUpScale factor must be >= 1 ! No point in rendering in less than target resolution..." );

			Material<VS_Pt4>	MaterialProcessSlices = ToDispose( new Material<VS_Pt4>( m_Device, "Process Slices Material", ShaderModel.SM4_0, new System.IO.FileInfo( "FX/VolumeMeshBuilder/ProcessSlices.fx" ) ) );
			Material<VS_Pt4>	MaterialBuildDistanceField = ToDispose( new Material<VS_Pt4>( m_Device, "Build Distance Field Material", ShaderModel.SM4_0, new System.IO.FileInfo( "FX/VolumeMeshBuilder/BuildDistanceField.fx" ) ) );
			Nuaj.Helpers.ScreenQuad	Quad = new Nuaj.Helpers.ScreenQuad( m_Device, "Quad" );

			//////////////////////////////////////////////////////////////////////////
			// 1] Determine the scene's BBox
			_SceneBBox = new BoundingBox( +float.MaxValue * Vector3.One, -float.MaxValue * Vector3.One );
			foreach ( Scene.Mesh M in m_Scene.Meshes )
			{
				BoundingBox	BBox = M.WorldBBox;
				_SceneBBox.Minimum = Vector3.Min( _SceneBBox.Minimum, BBox.Minimum );
				_SceneBBox.Maximum = Vector3.Max( _SceneBBox.Maximum, BBox.Maximum );
			}

			// Add a little offset to center the scene
			_SceneBBox.Minimum -= _SceneOffset * Vector3.One;
			_SceneBBox.Maximum += _SceneOffset * Vector3.One;

			Vector3	SceneCenter = 0.5f * (_SceneBBox.Minimum + _SceneBBox.Maximum);

			// Compute the integer volume's size
			Vector3	SceneSize = _SceneBBox.Maximum - _SceneBBox.Minimum;
			float	MaxDimension = Math.Max( Math.Max( SceneSize.X, SceneSize.Y ), SceneSize.Z );
			_VoxelSize = MaxDimension / _VolumeMaxSize;

			int		Width = (int) Math.Ceiling( SceneSize.X / _VoxelSize );
			int		Height = (int) Math.Ceiling( SceneSize.Y / _VoxelSize );
			int		Depth = (int) Math.Ceiling( SceneSize.Z / _VoxelSize );

			// Compute actual scene rendering size (should be a bit larger than the real scene as the volume encompasses the scene using integer voxels)
			Vector3	RenderSceneSize = _VoxelSize * new Vector3( Width, Height, Depth );


			//////////////////////////////////////////////////////////////////////////
			// 2] Create the temporary stacks of 2D textures
			RenderTarget<PF_RGBA16F>[]	StackDiffuse = new RenderTarget<PF_RGBA16F>[6];
			RenderTarget<PF_RGBA16F>[]	StackNormal = new RenderTarget<PF_RGBA16F>[6];

			int[]	StackDimensionX = new int[] { Depth, Width, Width };
			int[]	StackDimensionY = new int[] { Height, Depth, Height };
			int[]	StackDimensionZ = new int[] { Width, Height, Depth };

			for ( int StackIndex=0; StackIndex < 6; StackIndex++ )
			{
				int		StackWidth = StackDimensionX[StackIndex>>1];
				int		StackHeight = StackDimensionY[StackIndex>>1];
				int		StackSlicesCount = StackDimensionZ[StackIndex>>1];

				StackDiffuse[StackIndex] = new RenderTarget<PF_RGBA16F>( m_Device, "Diffuse Stack #" + StackIndex, StackWidth, StackHeight, 0, StackSlicesCount, 1 );
				StackNormal[StackIndex] = new RenderTarget<PF_RGBA16F>( m_Device, "Normal Stack #" + StackIndex, StackWidth, StackHeight, 0, StackSlicesCount, 1 );
			}

#if DEBUG_SLICES
m_StackDiffuse = StackDiffuse[2];
m_StackNormal = StackNormal[2];
#endif

			// Create 3 temporary render targets at higher resolution
			RenderTarget<PF_RGBA16F>[]	TempDiffuseAlphas = new RenderTarget<PF_RGBA16F>[3];
			RenderTarget<PF_RGBA16F>[]	TempNormals = new RenderTarget<PF_RGBA16F>[3];
			DepthStencil<PF_D32>[]		TempDepthStencils = new DepthStencil<PF_D32>[3];

			for ( int ViewSideIndex=0; ViewSideIndex < 3; ViewSideIndex++ )
			{
				int		ViewWidth = (int) Math.Floor( _StacksUpscale * StackDimensionX[ViewSideIndex] );
				int		ViewHeight = (int) Math.Floor( _StacksUpscale * StackDimensionY[ViewSideIndex] );

				TempDiffuseAlphas[ViewSideIndex] = new RenderTarget<PF_RGBA16F>( m_Device, "Temp Diffuse View #" + ViewSideIndex, ViewWidth, ViewHeight, 0 );
				TempNormals[ViewSideIndex] = new RenderTarget<PF_RGBA16F>( m_Device, "Temp Normal View #" + ViewSideIndex, ViewWidth, ViewHeight, 0 );
				TempDepthStencils[ViewSideIndex] = new DepthStencil<PF_D32>( m_Device, "Temp DepthStencil View #" + ViewSideIndex, ViewWidth, ViewHeight, false );
			}

			//////////////////////////////////////////////////////////////////////////
			// 3] Render the 6 stacks of slices in each principal direction
			Camera	Cam = new Camera( m_Device, "Ortho Camera" );
					Cam.Activate();

			Vector3[]	CamDimensions = new Vector3[]
			{
				// Left + Right
				new Vector3( RenderSceneSize.Z, RenderSceneSize.Y, RenderSceneSize.X ),
				// Top + Bottom
				new Vector3( RenderSceneSize.X, RenderSceneSize.Z, RenderSceneSize.Y ),
				// Front + Back
				new Vector3( RenderSceneSize.X, RenderSceneSize.Y, RenderSceneSize.Z ),
			};

			// Side transforms for cube map rendering
			Matrix[]	SideTransforms = new Matrix[6]
			{
				Matrix.RotationY( +0.5f * (float) Math.PI ),	// +X (look from right)
				Matrix.RotationY( -0.5f * (float) Math.PI ),	// -X (look from left)
				Matrix.RotationX( -0.5f * (float) Math.PI ),	// +Y (look from up)
				Matrix.RotationX( +0.5f * (float) Math.PI ),	// -Y (look from down)
				Matrix.RotationY( +0.0f * (float) Math.PI ),	// +Z (look from front) (default)
				Matrix.RotationY( +1.0f * (float) Math.PI ),	// -Z (look from back)
			};

			m_RenderScene.PreMultiplyByAlpha = _bPreMultiplyByAlpha;

			for ( int CubeFaceIndex=0; CubeFaceIndex < 6; CubeFaceIndex++ )
			{
				Vector3	CamDimension = CamDimensions[CubeFaceIndex>>1];
				float	CameraHeight = CamDimension.Y;
				float	AspectRatio = CamDimension.X / CameraHeight;

				RenderTarget<PF_RGBA16F>	DiffuseTarget = StackDiffuse[CubeFaceIndex];
				RenderTarget<PF_RGBA16F>	NormalTarget = StackNormal[CubeFaceIndex];
// 				m_Device.ClearRenderTarget( DiffuseTarget, Vector4.Zero );
// 				m_Device.ClearRenderTarget( NormalTarget, Vector4.Zero );

				RenderTarget<PF_RGBA16F>	TempDiffuseTarget = TempDiffuseAlphas[CubeFaceIndex>>1];
				RenderTarget<PF_RGBA16F>	TempNormalTarget = TempNormals[CubeFaceIndex>>1];
				DepthStencil<PF_D32>		TempDepthStencil = TempDepthStencils[CubeFaceIndex>>1];

				int		SlicesCount = DiffuseTarget.ArraySize;
				float	SliceDepth = CamDimension.Z / SlicesCount;

				// Setup camera transform
				Matrix	Camera2World = SideTransforms[CubeFaceIndex];
				Vector4	CameraPosition = new Vector4( SceneCenter, 1.0f ) - 0.5f * CamDimension.Z * Camera2World.Row3;
				Camera2World.Row4 = CameraPosition;

				Cam.Camera2World = Camera2World;

				// Render the slices
				for ( int SliceIndex=0; SliceIndex < SlicesCount; SliceIndex++ )
				{
					// Setup targets
					m_Device.SetMultipleRenderTargets( new RenderTarget<PF_RGBA16F>[] { TempDiffuseTarget, TempNormalTarget }, TempDepthStencil );
					m_Device.SetViewport( 0, 0, TempDiffuseTarget.Width, TempDiffuseTarget.Height, 0.0f, 1.0f );
					m_Device.ClearRenderTarget( TempDiffuseTarget, Vector4.Zero );
					m_Device.ClearRenderTarget( TempNormalTarget, Vector4.Zero );
					m_Device.ClearDepthStencil( TempDepthStencil, DepthStencilClearFlags.Depth, 1.0f, 0 );

					// Setup camera
					Cam.CreateOrthoCamera( CameraHeight, AspectRatio, (SliceIndex-0.5f) * SliceDepth, (SliceIndex+1.5f) * SliceDepth );

					// Render scene
					m_Renderer.Render();

					// Downscale temporary target to actual slice
					DownscaleTexture( MaterialProcessSlices, TempDiffuseTarget, TempNormalTarget, DiffuseTarget.Width, DiffuseTarget.Height, DiffuseTarget.GetSingleRenderTargetView( 0, SliceIndex ), NormalTarget.GetSingleRenderTargetView( 0, SliceIndex ) );
				}
			}

			// Dispose of temp views
			for ( int ViewSideIndex=0; ViewSideIndex < 3; ViewSideIndex++ )
			{
				TempDiffuseAlphas[ViewSideIndex].Dispose();
				TempNormals[ViewSideIndex].Dispose();
				TempDepthStencils[ViewSideIndex].Dispose();
			}

			//////////////////////////////////////////////////////////////////////////
			// 4] Build mip-maps
			m_Device.SetStockRasterizerState( Nuaj.Device.HELPER_STATES.NO_CULLING );
			m_Device.SetStockDepthStencilState( Nuaj.Device.HELPER_DEPTH_STATES.DISABLED );
			m_Device.SetStockBlendState( Nuaj.Device.HELPER_BLEND_STATES.DISABLED );

			using ( MaterialProcessSlices.UseLock() )
			{
				VariableVector		vBufferInvSize = MaterialProcessSlices.GetVariableByName( "BufferInvSize" ).AsVector;
				VariableVector		vPrevInvSize = MaterialProcessSlices.GetVariableByName( "PrevInvSize" ).AsVector;
				VariableResource	vSlicesDiffuse = MaterialProcessSlices.GetVariableByName( "SlicesDiffuse" ).AsResource;
				VariableResource	vSlicesNormal = MaterialProcessSlices.GetVariableByName( "SlicesNormal" ).AsResource;

				MaterialProcessSlices.CurrentTechnique = MaterialProcessSlices.GetTechniqueByName( "BuildMipMaps" );
				EffectPass			Pass = MaterialProcessSlices.CurrentTechnique.GetPassByIndex( 0 );

				MaterialProcessSlices.GetVariableByName( "PreMultiplyByAlpha" ).AsScalar.Set( _bPreMultiplyByAlpha );

				for ( int CubeFaceIndex=0; CubeFaceIndex < 6; CubeFaceIndex++ )
				{
					RenderTarget<PF_RGBA16F>	DiffuseTarget = StackDiffuse[CubeFaceIndex];
					RenderTarget<PF_RGBA16F>	NormalTarget = StackNormal[CubeFaceIndex];

					int	CurrentWidth = DiffuseTarget.Width;
					int	CurrentHeight = DiffuseTarget.Height;
					int	SlicesCount = DiffuseTarget.ArraySize;
					Vector3	InvSize = new Vector3( 1.0f / CurrentWidth, 1.0f / CurrentHeight, 0.0f );
					for ( int MipLevel=1; MipLevel < DiffuseTarget.MipLevelsCount; MipLevel++ )
					{
						CurrentWidth = Math.Max( 1, CurrentWidth >> 1 );
						CurrentHeight = Math.Max( 1, CurrentHeight >> 1 );
						SlicesCount = Math.Max( 1, SlicesCount >> 1 );

						m_Device.SetMultipleRenderTargets( new RenderTargetView[] { DiffuseTarget.GetArrayBandRenderTargetView( MipLevel, 0 ), NormalTarget.GetArrayBandRenderTargetView( MipLevel, 0 ) } );
						m_Device.SetViewport( 0, 0, CurrentWidth, CurrentHeight, 0.0f, 1.0f );

						vPrevInvSize.Set( InvSize );
						InvSize = new Vector3( 1.0f / CurrentWidth, 1.0f / CurrentHeight, 0.0f );
						vBufferInvSize.Set( InvSize );
						vSlicesDiffuse.SetResource( DiffuseTarget.GetArrayBandTextureView( MipLevel-1, 0 ) );
						vSlicesNormal.SetResource( NormalTarget.GetArrayBandTextureView( MipLevel-1, 0 ) );

						Pass.Apply();
						Quad.RenderInstanced( 0, SlicesCount );
					}
				}
			}


			//////////////////////////////////////////////////////////////////////////
			// 5] Build the 3D diffuse + normal textures
			_DiffuseAlpha = new RenderTarget3D<PF_RGBA16F>( m_Device, "Diffuse+Alpha", Width, Height, Depth, 0 );
			_Normal = new RenderTarget3D<PF_RGBA16F>( m_Device, "Normal", Width, Height, Depth, 0 );

			using ( MaterialProcessSlices.UseLock() )
			{
				VariableVector		vTargetSize = MaterialProcessSlices.GetVariableByName( "TargetSize" ).AsVector;
				VariableVector		vInvTargetSize = MaterialProcessSlices.GetVariableByName( "InvTargetSize" ).AsVector;

				VariableResource	vStackXm_Diffuse = MaterialProcessSlices.GetVariableByName( "StackXm_Diffuse" ).AsResource;
				VariableResource	vStackXp_Diffuse = MaterialProcessSlices.GetVariableByName( "StackXp_Diffuse" ).AsResource;
				VariableResource	vStackYm_Diffuse = MaterialProcessSlices.GetVariableByName( "StackYm_Diffuse" ).AsResource;
				VariableResource	vStackYp_Diffuse = MaterialProcessSlices.GetVariableByName( "StackYp_Diffuse" ).AsResource;
				VariableResource	vStackZm_Diffuse = MaterialProcessSlices.GetVariableByName( "StackZm_Diffuse" ).AsResource;
				VariableResource	vStackZp_Diffuse = MaterialProcessSlices.GetVariableByName( "StackZp_Diffuse" ).AsResource;
				VariableResource	vStackXm_Normal = MaterialProcessSlices.GetVariableByName( "StackXm_Normal" ).AsResource;
				VariableResource	vStackXp_Normal = MaterialProcessSlices.GetVariableByName( "StackXp_Normal" ).AsResource;
				VariableResource	vStackYm_Normal = MaterialProcessSlices.GetVariableByName( "StackYm_Normal" ).AsResource;
				VariableResource	vStackYp_Normal = MaterialProcessSlices.GetVariableByName( "StackYp_Normal" ).AsResource;
				VariableResource	vStackZm_Normal = MaterialProcessSlices.GetVariableByName( "StackZm_Normal" ).AsResource;
				VariableResource	vStackZp_Normal = MaterialProcessSlices.GetVariableByName( "StackZp_Normal" ).AsResource;

				MaterialProcessSlices.CurrentTechnique = MaterialProcessSlices.GetTechniqueByName( "Build3DTexture" );
				EffectPass			Pass = MaterialProcessSlices.CurrentTechnique.GetPassByIndex( 0 );

				int	CurrentWidth = Width;
				int	CurrentHeight = Height;
				int	CurrentDepth = Depth;
				for ( int MipLevel=0; MipLevel < StackDiffuse[0].MipLevelsCount; MipLevel++ )
				{
					m_Device.SetMultipleRenderTargets( new RenderTargetView[] { _DiffuseAlpha.GetSingleRenderTargetView( MipLevel ), _Normal.GetSingleRenderTargetView( MipLevel ) } );
					m_Device.SetViewport( 0, 0, CurrentWidth, CurrentHeight, 0.0f, 1.0f );

					vTargetSize.Set( new Vector3( CurrentWidth, CurrentHeight, CurrentDepth ) );
					vInvTargetSize.Set( new Vector3( 1.0f / CurrentWidth, 1.0f / CurrentHeight, 1.0f / CurrentDepth ) );

					// Upload the 6 stacks of views
					vStackXp_Diffuse.SetResource( StackDiffuse[0].GetArrayBandTextureView( MipLevel, 0 ) );
					vStackXm_Diffuse.SetResource( StackDiffuse[1].GetArrayBandTextureView( MipLevel, 0 ) );
					vStackYp_Diffuse.SetResource( StackDiffuse[2].GetArrayBandTextureView( MipLevel, 0 ) );
					vStackYm_Diffuse.SetResource( StackDiffuse[3].GetArrayBandTextureView( MipLevel, 0 ) );
					vStackZp_Diffuse.SetResource( StackDiffuse[4].GetArrayBandTextureView( MipLevel, 0 ) );
					vStackZm_Diffuse.SetResource( StackDiffuse[5].GetArrayBandTextureView( MipLevel, 0 ) );
					vStackXp_Normal.SetResource( StackNormal[0].GetArrayBandTextureView( MipLevel, 0 ) );
					vStackXm_Normal.SetResource( StackNormal[1].GetArrayBandTextureView( MipLevel, 0 ) );
					vStackYp_Normal.SetResource( StackNormal[2].GetArrayBandTextureView( MipLevel, 0 ) );
					vStackYm_Normal.SetResource( StackNormal[3].GetArrayBandTextureView( MipLevel, 0 ) );
					vStackZp_Normal.SetResource( StackNormal[4].GetArrayBandTextureView( MipLevel, 0 ) );
					vStackZm_Normal.SetResource( StackNormal[5].GetArrayBandTextureView( MipLevel, 0 ) );

					Pass.Apply();
					Quad.RenderInstanced( 0, CurrentDepth );

					// Scale dimensions
					CurrentWidth = Math.Max( 1, CurrentWidth >> 1 );
					CurrentHeight = Math.Max( 1, CurrentHeight >> 1 );
					CurrentDepth = Math.Max( 1, CurrentDepth >> 1 );
				}
			}


			//////////////////////////////////////////////////////////////////////////
			// 6] Smooth out the result
			if ( _SmoothRadius > 1e-3f )
			{
				RenderTarget3D<PF_RGBA16F> TempDiffuse = new RenderTarget3D<PF_RGBA16F>( m_Device, "Diffuse+Alpha", Width, Height, Depth, 0 );
				RenderTarget3D<PF_RGBA16F> TempNormal = new RenderTarget3D<PF_RGBA16F>( m_Device, "Normal", Width, Height, Depth, 0 );

				using ( MaterialProcessSlices.UseLock() )
				{
					MaterialProcessSlices.GetVariableByName( "SmoothRadius" ).AsScalar.Set( _SmoothRadius );

					VariableVector vTargetSize = MaterialProcessSlices.GetVariableByName( "TargetSize" ).AsVector;
					VariableVector vInvTargetSize = MaterialProcessSlices.GetVariableByName( "InvTargetSize" ).AsVector;
					VariableResource vSourceDiffuse = MaterialProcessSlices.GetVariableByName( "SourceDiffuse" ).AsResource;
					VariableResource vSourceNormal = MaterialProcessSlices.GetVariableByName( "SourceNormal" ).AsResource;

					MaterialProcessSlices.CurrentTechnique = MaterialProcessSlices.GetTechniqueByName( "Smooth3DTexture" );
					EffectPass Pass = MaterialProcessSlices.CurrentTechnique.GetPassByIndex( 0 );

					int CurrentWidth = Width;
					int CurrentHeight = Height;
					int CurrentDepth = Depth;
					for ( int MipLevel = 0; MipLevel < _DiffuseAlpha.MipLevelsCount; MipLevel++ )
					{
						m_Device.SetMultipleRenderTargets( new RenderTargetView[] { TempDiffuse.GetSingleRenderTargetView( MipLevel ), TempNormal.GetSingleRenderTargetView( MipLevel ) } );
						m_Device.SetViewport( 0, 0, CurrentWidth, CurrentHeight, 0.0f, 1.0f );

						vTargetSize.Set( new Vector3( CurrentWidth, CurrentHeight, CurrentDepth ) );
						vInvTargetSize.Set( new Vector4( 1.0f / CurrentWidth, 1.0f / CurrentHeight, 1.0f / CurrentDepth, 0.0f ) );
						vSourceDiffuse.SetResource( _DiffuseAlpha.GetSingleTextureView( MipLevel ) );
						vSourceNormal.SetResource( _Normal.GetSingleTextureView( MipLevel ) );

						Pass.Apply();
						Quad.RenderInstanced( 0, CurrentDepth );

						// Scale dimensions
						CurrentWidth = Math.Max( 1, CurrentWidth >> 1 );
						CurrentHeight = Math.Max( 1, CurrentHeight >> 1 );
						CurrentDepth = Math.Max( 1, CurrentDepth >> 1 );
					}
				}

				_DiffuseAlpha.Dispose();
				_Normal.Dispose();

				_DiffuseAlpha = TempDiffuse;
				_Normal = TempNormal;
			}

			//////////////////////////////////////////////////////////////////////////
			// 7] Build the distance field from the diffuse texture
			RenderTarget3D<PF_RGBA16F>[]	DistanceFields = new RenderTarget3D<PF_RGBA16F>[2]
			{
				new RenderTarget3D<PF_RGBA16F>( m_Device, "DistanceField #0", Width, Height, Depth, 0 ),
				new RenderTarget3D<PF_RGBA16F>( m_Device, "DistanceField #1", Width, Height, Depth, 0 )
			};

			using ( MaterialBuildDistanceField.UseLock() )
			{
				VariableVector		vBufferInvSize = MaterialBuildDistanceField.GetVariableByName( "BufferInvSize" ).AsVector;
				VariableResource	vPreviousDistanceField = MaterialBuildDistanceField.GetVariableByName( "PreviousDistanceField" ).AsResource;
				MaterialBuildDistanceField.GetVariableByName( "NormalField" ).AsResource.SetResource( _Normal );

				// 6.1] Initialize the distance field
				MaterialBuildDistanceField.CurrentTechnique = MaterialBuildDistanceField.GetTechniqueByName( "InitDistanceField" );

				m_Device.SetRenderTarget( DistanceFields[0] );
				m_Device.SetViewport( 0, 0, DistanceFields[0].Width, DistanceFields[0].Height, 0.0f, 1.0f );

				vBufferInvSize.Set( DistanceFields[0].InvSize4 );
				vPreviousDistanceField.SetResource( _DiffuseAlpha );
				
				MaterialBuildDistanceField.ApplyPass( 0 );
				Quad.RenderInstanced( 0, DistanceFields[0].Depth );

				// 6.2] Propagate the distance field
				MaterialBuildDistanceField.CurrentTechnique = MaterialBuildDistanceField.GetTechniqueByName( "PropagateDistanceField" );
				EffectPass	Pass = MaterialBuildDistanceField.CurrentTechnique.GetPassByIndex( 0 );

				for ( int PassIndex=0; PassIndex < _VolumeMaxSize; PassIndex++ )
				{
					m_Device.SetRenderTarget( DistanceFields[1] );
					vPreviousDistanceField.SetResource( DistanceFields[0] );

					Pass.Apply();
					Quad.RenderInstanced( 0, DistanceFields[1].Depth );

					// Swap fields
					RenderTarget3D<PF_RGBA16F>	Temp = DistanceFields[0];
					DistanceFields[0] = DistanceFields[1];
					DistanceFields[1] = Temp;

					m_Device.DirectXDevice.Flush();
				}

				// 6.3] Build the mip-maps
				MaterialBuildDistanceField.CurrentTechnique = MaterialBuildDistanceField.GetTechniqueByName( "BuildMipMaps" );
				Pass = MaterialBuildDistanceField.CurrentTechnique.GetPassByIndex( 0 );

				int	CurrentWidth = Width;
				int	CurrentHeight = Height;
				int	CurrentDepth = Depth;
				for ( int MipLevel=1; MipLevel < DistanceFields[0].MipLevelsCount; MipLevel++ )
				{
					CurrentWidth = Math.Max( 1, CurrentWidth >> 1 );
					CurrentHeight = Math.Max( 1, CurrentHeight >> 1 );
					CurrentDepth = Math.Max( 1, CurrentDepth >> 1 );

					m_Device.SetRenderTarget( DistanceFields[0].GetSingleRenderTargetView( MipLevel ) );
					vPreviousDistanceField.SetResource( DistanceFields[0].GetSingleTextureView( MipLevel-1 ) );

					vBufferInvSize.Set( new Vector4( 1.0f / CurrentWidth, 1.0f / CurrentHeight, 1.0f / CurrentDepth, 0.0f ) );

					Pass.Apply();
					Quad.RenderInstanced( 0, DistanceFields[1].Depth );
				}
			}

			// We got our final field
			_DistanceField = DistanceFields[0];
			DistanceFields[1].Dispose();

			//////////////////////////////////////////////////////////////////////////
			// Dispose of stuff
#if !DEBUG_SLICES
			for ( int StackIndex=0; StackIndex < 6; StackIndex++ )
			{
				StackDiffuse[StackIndex].Dispose();
				StackNormal[StackIndex].Dispose();
			}
#endif
			Cam.Dispose();

			Quad.Dispose();
			MaterialBuildDistanceField.Dispose();
			MaterialProcessSlices.Dispose();
		}

		/// <summary>
		/// Downscales the source diffuse/normal rendering into a target slice diffuse/normal
		/// </summary>
		/// <param name="_SourceDiffuse"></param>
		/// <param name="_SourceNormal"></param>
		/// <param name="_TargetDiffuse"></param>
		/// <param name="_TargetNormal"></param>
		protected void	DownscaleTexture( Material<VS_Pt4> _Mat, RenderTarget<PF_RGBA16F> _SourceDiffuse, RenderTarget<PF_RGBA16F> _SourceNormal, int _TargetWidth, int _TargetHeight, RenderTargetView _TargetDiffuse, RenderTargetView _TargetNormal )
		{
			m_Device.SetStockRasterizerState( Nuaj.Device.HELPER_STATES.NO_CULLING );
			m_Device.SetStockDepthStencilState( Nuaj.Device.HELPER_DEPTH_STATES.DISABLED );
			m_Device.SetStockBlendState( Nuaj.Device.HELPER_BLEND_STATES.DISABLED );

			using ( _Mat.UseLock() )
			{
				_Mat.CurrentTechnique = _Mat.GetTechniqueByName( "Downscale" );
				EffectPass Pass = _Mat.CurrentTechnique.GetPassByIndex( 0 );

				VariableResource	vSourceDiffuse = _Mat.GetVariableByName( "DownscaleSourceDiffuse" ).AsResource;
				VariableResource	vSourceNormal = _Mat.GetVariableByName( "DownscaleSourceNormal" ).AsResource;
				VariableVector		vSourceTextureSize = _Mat.GetVariableByName( "SourceTextureSize" ).AsVector;
				VariableVector		vTargetTextureSize = _Mat.GetVariableByName( "TargetTextureSize" ).AsVector;
				VariableVector		vSubPixelUVScale = _Mat.GetVariableByName( "SubPixelUVScale" ).AsVector;

				int	PreviousWidth, PreviousHeight;
				int	CurrentWidth = _SourceDiffuse.Width;
				int	CurrentHeight = _SourceDiffuse.Height;
				int	TargetMipIndex = 1;
				do
				{
					// Compute new size
					PreviousWidth = CurrentWidth;
					PreviousHeight = CurrentHeight;

					float	fScaleX = Math.Max( 0.5f, (float) _TargetWidth / CurrentWidth );
					CurrentWidth = Math.Max( _TargetWidth, (int) Math.Floor( fScaleX * PreviousWidth ) );
					float	fSubPixelScaleX = (float) PreviousWidth / CurrentWidth - 1.0f;

					float	fScaleY = Math.Max( 0.5f, (float) _TargetHeight / CurrentHeight );
					CurrentHeight = Math.Max( _TargetHeight, (int) Math.Floor( fScaleY * PreviousHeight ) );
					float	fSubPixelScaleY = (float) PreviousHeight / CurrentHeight - 1.0f;

					// Setup source scaling factors
					vSourceDiffuse.SetResource( _SourceDiffuse.GetSingleTextureView( TargetMipIndex-1, 0 ) );
					vSourceNormal.SetResource( _SourceNormal.GetSingleTextureView( TargetMipIndex-1, 0 ) );

					vSourceTextureSize.Set( new Vector2( PreviousWidth, PreviousHeight ) );
					vTargetTextureSize.Set( new Vector2( CurrentWidth, CurrentHeight ) );
					vSubPixelUVScale.Set( new Vector2( fSubPixelScaleX, fSubPixelScaleY ) );

					// Render
					if ( CurrentWidth == _TargetWidth && CurrentHeight == _TargetHeight )
						m_Device.SetMultipleRenderTargets( new RenderTargetView[] { _TargetDiffuse, _TargetNormal } );	// Final pass, render into designated target
					else
						m_Device.SetMultipleRenderTargets( new RenderTargetView[] { _SourceDiffuse.GetSingleRenderTargetView( TargetMipIndex, 0 ), _SourceNormal.GetSingleRenderTargetView( TargetMipIndex, 0 ) } );	// Temp pass, render into target mip level
					m_Device.SetViewport( 0, 0, CurrentWidth, CurrentHeight, 0.0f, 1.0f );

					Pass.Apply();
					m_Quad.Render();

					// Swap targets
					TargetMipIndex++;

				} while ( CurrentWidth != _TargetWidth || CurrentHeight != _TargetHeight );
			}
		}

		#endregion

		#region Geometry Shader Code Generation

		protected void	BuildGSCode()
		{
			string	Result = "";
			for( int C2=0; C2 <= 2; C2++ )
				for ( int C1=0; C1 <= 2; C1++ )
					for ( int C0=0; C0 <= 2; C0++ )
					{
// C0 = 0;
// C1 = 1;
// C2 = 2;
						int	CaseIndex = C0 + 3*C1 + 9*C2;
						if ( CaseIndex == 0 || CaseIndex == 26 )
							continue;	// Invalid cases...


						string	Temp = "";

						float[]	s = new float[]
						{
							C0 == 0 ? -1.0f : (C0 == 1 ? 0.5f : 2.0f),
							C1 == 0 ? -1.0f : (C1 == 1 ? 0.5f : 2.0f),
							C2 == 0 ? -1.0f : (C2 == 1 ? 0.5f : 2.0f),
						};

						// Apply the algorithm and emit code
						int	VerticesCount = 0;
						for ( int k=0; k < 3; k++ )
						{
							int	kleft = (k+2)%3;
							int	kright = (k+1)%3;

							if ( s[k] >= 0.0f && s[k] <= 1.0f )
							{
								Temp = EmitIntersect( Temp, "Bottom", k, "Top", k, ref VerticesCount );
							}
							else if ( s[k] < 0.0f )
							{
								if ( s[kleft] >= 0.0f )
									Temp = EmitIntersect( Temp, "Bottom", k, "Bottom", kleft, ref VerticesCount );
								if ( s[kright] >= 0.0f )
									Temp = EmitIntersect( Temp, "Bottom", k, "Bottom", kright, ref VerticesCount );
							}
							else if ( s[k] > 1.0f )
							{
								if ( s[kleft] <= 1.0f )
									Temp = EmitIntersect( Temp, "Top", k, "Top", kleft, ref VerticesCount );
								if ( s[kright] <= 1.0f )
									Temp = EmitIntersect( Temp, "Top", k, "Top", kright, ref VerticesCount );
							}
						}

						int	TrianglesCount;
						Temp = EmitTriangles( Temp, VerticesCount, out TrianglesCount );

						// Build CASE segment
						Result += "case " + CaseIndex + ":	// " + C0 + C1 + C2 + " Emits " + TrianglesCount + " triangle" + (TrianglesCount > 1 ? "s" : "") + "\r\n";
						Result += Temp;
						Result += "	break;\r\n";
					}
		}

		protected string	EmitIntersect( string _Result, string _P0, int _k0, string _P1, int _k1, ref int _VerticesCount )
		{
			_Result += "	Intersect( _Triangle" + _P0 + "[" + _k0 + "], _Triangle" + _P1 + "[" + _k1 + "], _UVW" + _P0 + "[" + _k0 + "], _UVW" + _P1 + "[" + _k1 + "], _Z, Out[" + _VerticesCount + "] );\r\n";
			_VerticesCount++;
			return _Result;
		}

		protected string	EmitTriangles( string _Result, int _VerticesCount, out int _TrianglesCount )
		{
			if ( _VerticesCount < 3 || _VerticesCount > 5 )
				throw new Exception( "Shouldn't happen !" );

			if ( _VerticesCount == 3 )
			{	// Single triangle
				_TrianglesCount = 1;
				_Result += "	_Stream.Append( Out[0] );\r\n";
				_Result += "	_Stream.Append( Out[1] );\r\n";
				_Result += "	_Stream.Append( Out[2] );\r\n";
			}
			else if ( _VerticesCount == 4 )
			{	// 2 triangles in a single strip
				_TrianglesCount = 2;
				_Result += "	_Stream.Append( Out[1] );\r\n";
				_Result += "	_Stream.Append( Out[0] );\r\n";
				_Result += "	_Stream.Append( Out[2] );\r\n";
				_Result += "	_Stream.Append( Out[3] );\r\n";
			}
			else
			{	// 3 triangles in 2 strips
				_TrianglesCount = 3;
				_Result += "	_Stream.Append( Out[1] );\r\n";
				_Result += "	_Stream.Append( Out[0] );\r\n";
				_Result += "	_Stream.Append( Out[2] );\r\n";
				_Result += "	_Stream.Append( Out[3] );\r\n";
				_Result += "	_Stream.RestartStrip();\r\n";
				_Result += "	_Stream.Append( Out[0] );\r\n";
				_Result += "	_Stream.Append( Out[3] );\r\n";
				_Result += "	_Stream.Append( Out[4] );\r\n";
			}

			return _Result;
		}

		#endregion

		protected void	WriteTexParams( System.IO.Stream _Stream, ITexture3D _DiffuseAlpha, float _VoxelSize, BoundingBox _SceneBBox )
		{
			System.IO.BinaryWriter	Writer = new System.IO.BinaryWriter( _Stream );

			Writer.Write( _DiffuseAlpha.Width );
			Writer.Write( _DiffuseAlpha.Height );
			Writer.Write( _DiffuseAlpha.Depth );
			Writer.Write( _VoxelSize );
			Writer.Write( _SceneBBox.Minimum.X );
			Writer.Write( _SceneBBox.Minimum.Y );
			Writer.Write( _SceneBBox.Minimum.Z );
			Writer.Write( _SceneBBox.Maximum.X );
			Writer.Write( _SceneBBox.Maximum.Y );
			Writer.Write( _SceneBBox.Maximum.Z );
			Writer.Write( PREMULTIPLY_BY_ALPHA );
		}

		protected void	ReadTexParams( System.IO.Stream _Stream, out int _VolumeWidth, out int _VolumeHeight, out int _VolumeDepth, out float _VoxelSize, out BoundingBox _SceneBBox, out bool _PremultipliedAlpha )
		{
			System.IO.BinaryReader	Reader = new System.IO.BinaryReader( _Stream );

			_VolumeWidth = Reader.ReadInt32();
			_VolumeHeight = Reader.ReadInt32();
			_VolumeDepth = Reader.ReadInt32();
			_VoxelSize = Reader.ReadSingle();
			_SceneBBox = new BoundingBox(
				new Vector3( Reader.ReadSingle(), Reader.ReadSingle(), Reader.ReadSingle() ),
				new Vector3( Reader.ReadSingle(), Reader.ReadSingle(), Reader.ReadSingle() ) );
			_PremultipliedAlpha = Reader.ReadBoolean();
		}

		protected void	WriteTexParamsTEXT( System.IO.StreamWriter _Writer, ITexture3D _DiffuseAlpha, float _VoxelSize, BoundingBox _SceneBBox )
		{
			_Writer.WriteLine( "float		VoxelSize = " + _VoxelSize + "f;" );
			_Writer.WriteLine( "BoundingBox	SceneBBox = new BoundingBox( new Vector3( " + _SceneBBox.Minimum.X + "f, " + _SceneBBox.Minimum.Y + "f, " + _SceneBBox.Minimum.Z + "f ), " +
																		"new Vector3( " + _SceneBBox.Maximum.X + "f, " + _SceneBBox.Maximum.Y + "f, " + _SceneBBox.Maximum.Z + "f ) );" );
			_Writer.WriteLine( "int			VolumeWidth = " + _DiffuseAlpha.Width + ", VolumeHeight = " + _DiffuseAlpha.Height + ", VolumeDepth = " + _DiffuseAlpha.Depth + ";" );
		}

		#endregion

		#region EVENT HANDLERS

		private void buttonProfiler_Click( object sender, EventArgs e )
		{
			m_Profiler.Show( this );
		}

		private void integerTrackbarControlBoxesCount_ValueChanged( Nuaj.Cirrus.Utility.IntegerTrackbarControl _Sender, int _FormerValue )
		{
			Box[]	Temp = new Box[_Sender.Value];
			m_TotalBoxes.CopyTo( 0, Temp, 0, _Sender.Value );

			m_CurrentBoxes.Clear();
			m_CurrentBoxes.AddRange( Temp );
		}

		#endregion
	}
}
